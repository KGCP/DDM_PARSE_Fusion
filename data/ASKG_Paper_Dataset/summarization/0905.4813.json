{"sections": {"Abstract": "b'{\"search-keyword: clean-text| displaying exact matches\":\"Logical Methods in Computer Science\\\\nVol. 5 (3:9) 2009, pp. 117\\\\nwww.lmcs-online.org\\\\n\\\\nSubmitted\\\\nPublished\\\\n\\\\nJul. 14, 2008\\\\nSep. 15, 2009\\\\n\\\\nREPRESENTATIONS OF STREAM PROCESSORS USING NESTED\\\\nFIXED POINTS\\\\nPETER HANCOCK a , DIRK PATTINSON b , AND NEIL GHANI c\\\\na\\\\n\\\\nSchool of Computer Science, University of Nottingham, Jubilee Campus, Nottingham, NG8 1BB\\\\ne-mail address: hancock@spamcop.net\\\\n\\\\nb\\\\n\\\\nDepartment of Computing, Imperial College London, 180 Queens Gate, London SW7 2AZ\\\\ne-mail address: dirk@doc.ic.ac.uk\\\\n\\\\nc\\\\n\\\\nComputer and Information Sciences, University of Strathclyde, Livingstone Tower, 26 Richmond\\\\nSt, Glasgow G1 1XH\\\\ne-mail address: neil.ghani@cis.strath.ac.uk\\\\nAbstract. We define representations of continuous functions on infinite streams of discrete values, both in the case of discrete-valued functions, and in the case of stream-valued\\\\nfunctions. We define also an operation on the representations of two continuous functions\\\\nbetween streams that yields a representation of their composite.\\\\nIn the case of discrete-valued functions, the representatives are well-founded (finitepath) trees of a certain kind. The underlying idea can be traced back to Brouwers justification of bar-induction, or to Kreisel and Troelstras elimination of choice-sequences. In\\\\nthe case of stream-valued functions, the representatives are non-wellfounded trees pieced\\\\ntogether in a coinductive fashion from well-founded trees. The definition requires an alternating fixpoint construction of some ubiquity.\\\\n\\\\n", "Introduction": "Introduction\\\\nThis paper is concerned with the representation and implementation of continuous\\\\nfunctions on spaces of infinite sequences or streams of discrete values, such as binary digits\\\\n(Cantor space), or natural numbers (Baire space). That is to say, we will look at functions\\\\nof type\\\\nf : A  X\\\\nwhere A is a discrete space, A is the space of streams of elements of A with the product\\\\ntopology, and X is either a discrete space B, or itself a space of streams B  . We use the\\\\nsymbol  for the continuous function space. Functions of this kind and closely related\\\\nkinds arise in many contexts in mathematics and are pervasive in programming, as with\\\\npipes, stream input-output and coroutines.\\\\n1998 ACM Subject Classification: 68P05, 68N18, 54C35.\\\\nKey words and phrases: Streams, continuous functions, initial algebras, final coalgebras.\\\\na\\\\nHancocks work was supported by EPSERC grant EP/C511964/1.\\\\n\\\\nl\\\\n\\\\nLOGICAL METHODS\\\\nIN COMPUTER SCIENCE\\\\n\\\\nDOI:10.2168/LMCS-5 (3:9) 2009\\\\n\\\\nc P. Hancock, D. Pattinson, and N. Ghani\\\\n\\\\nCC\\\\n\\\\nCreative Commons\\\\n\\\\n\\\\f2\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\nIf one is to implement such a function by means of a program or machine that consumes\\\\nsuccessive values in an input stream, and produces a value (all at once in the discrete\\\\ncase, or in a stream of successive values in the stream-valued case), it seems necessary\\\\nthat the function be continuous. Otherwise, the whole input stream would be needed at\\\\nonce: an output would be forthcoming only at the end of time. Continuity means that\\\\nfinite information concerning the output of the function is determined by finite information\\\\nconcerning its input. In the simpler, discrete-valued case, this amounts to the requirement\\\\nthat the value b = f  of the function at argument  is determined (or secured) by some\\\\nfinite prefix n = (0 , 1 , 2 , . . . , n1 ) of .\\\\nIt is fairly clear how to represent continuous functions on A with discrete values in B:\\\\ntake a well-founded tree branching over A, with Bs at the leaves. Such a tree represents a\\\\ncontinuous function. Start at the root, then use successive entries in the argument stream\\\\nto steer your way along some path to a leaf. When you arrive at the leaf, as you inevitably\\\\nmust in view of the trees being well-founded, there is your value for that argument. We\\\\ncan visualise the representation as follows.\\\\n\\\\n0\\\\n\\\\n@\\\\n@\\\\n@\\\\n@\\\\n@\\\\n@\\\\n1\\\\n@\\\\n@\\\\n@\\\\n\\\\n0\\\\n\\\\nf : 2  2\\\\nf (0, . . .)\\\\nf (1, 0, . . .)\\\\nf (1, 1, 0, . . .)\\\\nf (1, 1, 1, . . .)\\\\n\\\\n=\\\\n=\\\\n=\\\\n=\\\\n\\\\n0\\\\n1\\\\n0\\\\n1\\\\n\\\\n1\\\\n\\\\nAt the black inner nodes, the representation eats the next entry in the argument\\\\nstream, and goes left or right according to whether its 0 or 1; at leaves, it spits the\\\\n(boxed) value for that argument.\\\\nIt should be noted that there will be several (actually, infinitely many) representations\\\\nof the same function. For example, the tree below represents the same function as the\\\\none above, where (of course) two functions are the same if their values are equal for all\\\\narguments.\\\\n\\\\n\\\\n0\\\\n\\\\n@\\\\n@\\\\n@\\\\n@\\\\n@\\\\n@\\\\n1\\\\n@\\\\n@\\\\n@\\\\n\\\\n1\\\\n@\\\\n@\\\\n@\\\\n\\\\n0\\\\n\\\\n0\\\\n\\\\nIt is perhaps a little less obvious that the representation sketched above is complete:\\\\nany continuous function f : A  B is representable in this way. The most straightforward\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n3\\\\n\\\\nargument is irredeemably classical: suppose the function has no representation, and derive\\\\nfrom this supposition a stream at which it is not continuous. However the completeness\\\\nof the representation can be established constructively, given only the validity of a certain\\\\nprinciple of called bar induction, asserting the equivalence of two notions of barred-ness,\\\\nor covering in Baire space. Here a bar is a monotone subset of A , the set of finite lists\\\\nof As. One notion of barred-ness is weak, having the form of a quantification over infinite\\\\nsequences\\\\n( : A )(n : ) Bh0 , . . . , n1 i .\\\\nThe other notion of barred-ness is strong, being inductively defined, and so having essentially\\\\nthe form of a quantification over subsets of A\\\\n(U  A )B  { c : A | (a : A)U (c  a) }  U  U hi\\\\nwhere hi denotes the empty list, and c  a the list c with a further entry a at the end.\\\\nUsing a variant of this principle, one can show that the two notions of continuity on Baire\\\\nspace (one the usual epsilon-delta definition, the other defined inductively) coincide. This\\\\nprinciple is closely related to Brouwers Bar Theorem, for which he presented a fascinating\\\\nbut fallacious1 argument in three articles. There is an extensive discussion of Brouwers\\\\nargument by Dummett in [4, pp 6875], and a more formal analysis of bar induction by\\\\nHoward and Kreisel in [8]. A very penetrating discussion of bar induction that is closely\\\\nrelated to our representation of continuous functions by well-founded trees is given by Tait\\\\nin [18].\\\\nThe inspiration for our representation of continuous functions with discrete codomain\\\\nwas in fact Brouwers argument for bar-induction, that conjures an inductive structure from\\\\na proof of a 11 statement  n . . .. This inductive content was made explicit by Kreisel\\\\nand Troelstra [20, 8.4, p225] in the form of the class K of neighbourhood functions central\\\\nto their so-called elimination of choice sequences, discussed in [4, pp 7581] and [18]. In\\\\nthis paper, we put this inductive structure into a datatype. In fact the paper of Taits just\\\\ncited contains (at the bottom of p.195) a definition of what amounts to the function eat in\\\\nsection 2.1 below, differing only in notation. We claim no originality for this insight.\\\\nNow what about stream-valued continuous functions on A with values in B  ? The\\\\nidea is again quite simple, though as far as we know, new. It is also difficult to depict. What\\\\nwe want is a non-wellfounded tree, branching over A, along every path of which there are\\\\ninfinitely many nodes labelled with an element of B. Start at the root, then use successive\\\\nentries in the argument stream to steer your way along some path. Whenever you arrive\\\\nat a node labelled with an element of B, as you will inevitably do infinitely often, emit\\\\nthat element as the next entry in the output stream. It turns out to be straightforward\\\\nto express the type of trees we need as a nested fixed point, in which one forms the final\\\\ncoalgebra of a functor that is defined using an initial algebra construction.\\\\nIs this representation complete? It turns out that every stream-valued function on\\\\nstreams is representable by a non-wellfounded tree of the kind we have described, though\\\\nthe argument is perhaps a little intricate.\\\\nOur main contribution, non-trivially extending the state of the art in the 1960s, is to\\\\nformulate a represention of stream processing components (continuous functions between\\\\n1Brouwer did not place any restriction such as monotonicity on B. As explained by Dummett [4, pp\\\\n\\\\n6875] this is definitely an error.\\\\n\\\\n\\\\f4\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\nstreams, including their composition), different from that customary in the logical literature2, that fits better with practical implementation of stream computation.\\\\nThe datatype of representations provides a convenient basis for writing stream processing components in a functional programming language such as Haskell. Nevertheless, the\\\\ncoding in Haskell is not entirely satisfying. The chief advantage of using our data type to\\\\nprogram stream processing components is that it ensures liveness, through the use of mixed\\\\ninductive-coinductive types. The foundations of Haskell are located in a theory of partial\\\\nfunctions, and not functions in the standard mathematical sense. Totality is something\\\\nextrinsic, beyond the scope of the type system. Our approach guarantees that the stream\\\\nprocessors are total. So it might be better expressed in a language for total functional\\\\nprogramming, as advocated by Turner [21], and approximated in systems such as Epigram\\\\nand Agda. This means that evaluation of the constructor form of the value of a function at\\\\nan argument in its domain must terminate, in our opinion something to be striven for in a\\\\npractical programming language.\\\\nIt seems that there are lessons to be learnt from this work for t", "Related Work": "he design of formalisms\\\\nand systems for developing dependently typed programs. It is not yet entirely clear what\\\\nfacilities for coinductive definition and reasoning such systems need to provide, and in what\\\\nform. It seems firstly that facilities for inductive-recursive definition may be needed in\\\\nconnection with coinductive structures: the neighbourhoods in coinductive types have an\\\\ninductive-recursive construction. (Admittedly, this structure does not become fully evident\\\\nuntil we consider more general coinductive datatypes than streams.) Secondly, inductive\\\\nand coinductive definitions are sometimes nested within each other (as in ( X) ( Y ) B \\\\nX + Y A ). Coding our constructions in current systems for dependently typed programming\\\\nhas revealed a number of deficiencies and errors in these systems. Dealing with recursive\\\\ndefinitions in which induction and coinduction are combined needs careful analysis, that\\\\nin our opinion should be based on the universal properties of initial algebras and final\\\\ncoalgebras.\\\\nThe paper is organised as follows.\\\\n Section 1: preliminaries.\\\\n Section 2: we define the representation of the continuous function space A  B by the\\\\ndatatype TA B = ( X) B + X A of wellfounded trees branching over A and terminating\\\\nin B, and show it is complete in the sense that each such continuous function has a\\\\nrepresentative (in fact many) in TA B. This part of the paper is in essence fairly well\\\\nknown.\\\\n Section 3: we define the representation of the continuous function space A  B  by\\\\nPA B = ( Y ) TA (B  Y ). The main contribution here is the proof of completeness, which\\\\nis not completely straightforward. The proof is constructive, given completeness in the\\\\ndiscrete-valued case.\\\\n Section 4: we define two representations of composition, as operators of type PB C \\\\nPA B  PA C, and show their correctness. As far as we have been able to discover, this\\\\nrepresentation is new.\\\\n Section 5: in conclusion, we summarise what has been done, point out related work, and\\\\nindicate some directions for further work.\\\\n2According to this, if k represents a function f :    B, then  :    B  is represented by k where\\\\nf\\\\nf\\\\n\\\\nf (n # ) = (, n). This manoeuver works only when  is a stream of natural numbers, or encodable as such.\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n5\\\\n\\\\nThe main definitions of the paper can be transcribed quite simply into Haskell. A Haskell\\\\nencoding can be found at http://personal.cis.strath.ac.uk/ng/eating.hs.\\\\n1. Preliminaries\\\\nWe assume the reader is familiar with the categorical notions of product, coproduct,\\\\nand exponential, and standard notations associated with these. We use  as infix notation\\\\nfor composition, with (as usual) postponent at left and preponent at right.\\\\n1.1. Streams. If A is a set, we write A for the set of countably infinite streams (sequences) of elements of A, and A for the set of finite sequences (lists) of elements of\\\\nA.\\\\nWe use Greek letters , , . . . as variables over stream types. We overload the infix\\\\noperator (#) (with section notation) our basic means of constructing both streams and nonempty lists. Thus if a : A, then the following functions prefix a to streams and to lists.\\\\n(a #) : A  A\\\\n\\\\n(a #) : A  A\\\\n\\\\nWe also have the empty list  : A .\\\\nAs destructors of streams we use hd and tl .\\\\nhd : A  A\\\\ntl : A  A\\\\nFor all a : A and  : A we have\\\\nhd (a # ) = a : A\\\\ntl ( # ) =  : A\\\\n = (hd ) #(tl ) : A\\\\nHere we have for clarity written for parts of expressions that need not be named. The\\\\ndestructors hd and tl are used implicitly in pattern-matching definitions.\\\\nWe sometimes write 0 for hd , and  for tl .\\\\nWe use the function () : A  (A ) which returns the stream of finite prefixes of its\\\\nargument. It is defined by (0) =  and (n + 1) = (0) #( )(n).\\\\nStreams are endowed with a topology in which the neighbourhoods are given by finite\\\\nsequences c : A . Each such represents the predicate N c = {  | c = (len c) } of streams\\\\nsharing prefix c. We usually suppress the distinction between c : A and N c  A . The\\\\nrelation   N c can be defined by recursion on list c.\\\\nWe use  for the continuous function space. Thus A  X consists of the continuous\\\\nfunctions from A to X, where X is either a discrete space D, or a space D  where D is\\\\ndiscrete.\\\\n A discrete valued continuous function f : A  D is continuous at  : A if there is some\\\\nneighbourhood of  throughout which f is constant. In other words, there exists n  \\\\nsuch that f has the same value throughout the neighbourhood  n.\\\\nimage f ( n) = { f  }\\\\nA\\\\n\\\\n D consists of functions that are continuous throughout A .\\\\n\\\\n\\\\f6\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\n A stream-valued continuous function f : A  B  is continuous at  : A if (n \\\\n)(m  )f ((m))  f  n, or in other words to find out a finite amount of information\\\\nabout the value, one need only provide a finite amount of information about the argument.\\\\nA  B  consists of functions that are continuous throughout A . If m does not depend\\\\non , the function is uniformly continuous. Such a function f is contractive if it decreases\\\\nthe distance between streams. Prime examples of contractors are the functions (a #) :\\\\nA  A , indexed by a : A.\\\\n1.2. Initial algebras and final coalgebras. We use ( X) F (X) = F and ( X) F (X) =\\\\nF to denote initial and final coalgebras for an endofunctor F , typically an endofunctor on\\\\nthe category of sets.\\\\nInitial algebras In general we use in for the structure map into the carrier of an initial\\\\nalgebra. Thus in : F ( F )  (F ). Given an algebra C,  : F C  C, we let fold (C; ), or\\\\nsimply fold  to denote the unique morphism  :  F  C such that\\\\n  in =   F .\\\\nin 1\\\\n\\\\nWe use\\\\nfor the inverse of the structure map, namely fold (F in).\\\\n\\\\nExample: finite sequences A = ( X) 1 + A  X. We use  and (#) as constructors\\\\nassociated with  , so\\\\n\\\\n\\\\n/ A\\\\n1\\\\n(#)\\\\n/ A\\\\nA  A\\\\nin = [|(#)] : 1 + A  A  A\\\\n\\\\n\\\\nExample: TA B = ( X) B + X A , defined in section 2. The bifunctor TA B is covariant\\\\nin B, and contravariant in A. For fixed A, TA : Set  Set is actually the free monad over\\\\nthe functor ( )A (alias (A ), known as the reader monad). Intriguingly, our constructions\\\\nall pivot on the freeness of this monad. TA is also known as the tree monad. We use Ret\\\\nand Get for the constructors associated with TA . Thus\\\\nB\\\\n\\\\nRet\\\\n\\\\n/ TA B\\\\n\\\\nGet\\\\n\\\\n/ TA B\\\\n(TA B)A\\\\nin = [Ret|Get] : B + (TA B)A  TA B\\\\n\\\\nFinal coalgebras In general we use out for the structure map from the carrier of\\\\na final coalgebra. Thus out : F  F (F ). Given a coalgebra C,  : C  F C, we use\\\\nunfold (C; ), or simply unfold  (also called the coiteration of ) to denote the unique\\\\ncoalgebra morphism  : C  F such that\\\\nout   = F   \\\\nout 1\\\\n\\\\nWe use\\\\nfor the inverse of the structure map, namely unfold (F out).\\\\nExample: streams A . We use hd and tl to access components of a stream. out =\\\\nhhd , tl i : A  A  A , while out 1 ha, i = a # .\\\\n\\\\nExample: PA B = ( X) TA (B  X), defined in section 3.\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n7\\\\n\\\\n2. Discrete codomain\\\\n\\\\n\\\\nRecall (from section 1.2) that TA B = ( X) B + X A . In this section we define a\\\\nfunction eat of type TA B  A  B  A that allows us to represent continuous functions\\\\nin A  B using elements of TA B. Then we give a non-constructive argument that this\\\\nrepresentation is complete.\\\\n\\\\n\\\\n2.1. Definition of eat . Let MA B = A  (B  A ) be the state monad, with state set\\\\nA . (The state is the suffix of the input stream that remains unread.) The unit and bind\\\\n(infix >>=) operators of the state monad are as follows.\\\\n : B  MA B\\\\n(>>=) : MA B  (B  MA C)  MA C\\\\n\\\\n(b) = ( ) hb, i\\\\n\\\\n(m >>= f ) = ( ) let hi,  i = m in f (i,  )\\\\nNote that MA supports the operation of reading one input:\\\\nget : MA A\\\\nget  = h0 ,  i\\\\nThis function plays an important r\\\\nole below in the guise of hhd , tl i : A \\\\n= A  A .\\\\nThe most straightfoward definition of eat is by structural recursion.\\\\neat : TA B\\\\n MA B\\\\neat (Ret b) =  b\\\\neat (Get ) = get >>= (eat  )\\\\n2.2. Completeness. The following result is in essence well known.\\\\nTheorem 2.1. (Completeness of representation of A  B by TA B.) There is a function\\\\nrep : (A  B)  TA B such that if f : A  B then 0  (eat (rep f )) = f\\", "Methodology": "\\nNote that rep picks a representative for a continuous function from those that give rise\\\\nto extensionally the same function. When A is infinite, there are uncountably many such\\\\nrepresentatives.\\\\nProof. (Classical) Suppose that some function f : A  B has no representative. We\\\\nconstruct an argument  : A at which f is not continuous. Thence, if f is continuous at\\\\nall arguments, there exists some r : TA B such that eat(r) equals f .\\\\nStarting with f : A  B, we construct an infinite sequence of functions without\\\\nrepresentatives. In the first place, for some a : A, the function f  (a #) has no representative.\\\\n(Else f itself would have a representation.) By a form of the axiom of dependent choices,\\\\nif f : A  B has no representative, then for some  : A , none of the functions\\\\nf0 = f, f1 = f0  (0 #), f2 = f1  (1 #) = f  (0 #)  (1 #), . . .\\\\nhave representatives. In particular, none of these functions can be constant. It follows that\\\\nf is not constant in any neighbourhood of , and so f is not continuous at .\\\\n\\\\n\\\\f8\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\nThe structure of this proof is discussed in Dummett [4, pp 4955], and Troelstra and\\\\nvan Dalen [20, 8.7, p227]. Of course, there are other proofs that do not make use of\\\\nconstructively illicit forms of contraposition. For example, there seem to be proofs that\\\\nuse instead monotone bar-induction, and are arguably intuitionistically valid. However as\\\\nindicated by Tait in [18, pp 194196], the best we can hope to achieve from a constructive\\\\npoint of view is to find models of suitable systems of constructive reasoning to which we\\\\nhave adjoined an axiom asserting that a function of type A  B continuous in the weak\\\\no sense is always continuous in the strong inductive sense. It is to be expected that such\\\\na model would refute Churchs thesis.\\\\n3. Stream codomain\\\\n\\\\n\\\\nRecall (from section 1.2) that PA B = ( X) TA (B  X). The previous section gave a\\\\ncomplete representation of discrete valued continuous functions A  B, where A and B\\\\nare discrete. We turn now to stream-valued functions. First we define a function eat  with\\\\ntype PA B  A  B  . We have not been able to find a similar representation in the\\\\nliterature. Then we provide it with a right-inverse rep  .\\\\nOf course, A  B  is isomorphic to (A  B) , and so its elements can be represented\\\\nby streams of representations of A  B. However such a representation would be unusable\\\\nin practice, as the same input stream would have to be scanned again and again to produce\\\\nsuccessive items in the output stream.\\\\n3.1. Definition of eat  . We define eat  to be the curried form of a function e of type\\\\n(PA B)  A  B  that is continuous in its second argument. Since B  is a final coalgebra,\\\\nto define a function into it, it is enough to define a coalgebra for (B) with carrier PA BA .\\\\nPA B  A\\\\n\\\\ne\\\\n\\\\n/ B\\\\n\\\\nout 1\\\\n\\\\n\\\\u000f\\\\n\\\\nTA (B  PA B)  A\\\\neat1\\\\n\\\\n\\\\u000f\\\\n\\\\nMA (B  PA B)  A\\\\n\\\\nhhd ,tli\\\\n\\\\napp\\\\n\\\\n\\\\u000f\\\\n\\\\n(B  PA B)  A\\\\nassoc\\\\n\\\\n\\\\u000f\\\\n\\\\nB  (PA B  A )\\\\nSo\\\\nThen\\\\n\\\\n1e\\\\n\\\\n\\\\u000f\\\\n/ B  B\\\\n\\\\ne : PA B  A  B \\\\ne = unfold (assoc  app  ((eat  out)  1) .\\\\neat  : PA B  A  B \\\\neat  = curry e .\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n9\\\\n\\\\nA more down-to-earth or humane presentation of the definition of eat  follows, as it\\\\nmight be written in a functional programming language.\\\\ndata T a b = Ret b | Get(a  T a b)\\\\neat :: T a b  Str a  (b, Str a)\\\\neat (Ret b) as\\\\n= (b, as)\\\\neat (Get f ) (a : as) = eat (f a) as\\\\ndata P a b = P(T a (b, P a b))\\\\neat  :: P a b  Str a  Str b\\\\neat  (P t) as = let ((b, p), as  ) = eat t as in\\\\nb : eat  p as \\\\nRemark: this definition generalises effortlessly to the case when the codomain is an\\\\narbitrary final coalgebra for a strong functor F (that is, one equipped with a suitable\\\\n\\\\nnatural transformation strength : F X  Y  F (X  Y )). Let R = (TA  F ).\\\\ne\\\\n\\\\nR  A\\\\n\\\\n/ F\\\\n\\\\nout 1\\\\n\\\\n\\\\u000f\\\\n\\\\nTA (F R)  A\\\\napp(eat 1)\\\\n\\\\nout\\\\n\\\\n\\\\u000f\\\\n\\\\n(F R)  A\\\\nstrength\\\\n\\\\n\\\\u000f\\\\n\\\\nF (R  A )\\\\n\\\\nF (e )\\\\n\\\\n\\\\u000f\\\\n/ F (F )\\\\n\\\\nThough one can thus represent functions from streams into arbitrary final coalgebras, it is\\\\nnot clear what a completeness result for this general representation would be. Without some\\\\nserious restriction on the functor F it does not seem possible to conjure up a useful topology\\\\non the codomain F . In fact, this is possible for functors that represent a single sorted\\\\nsignature of finite arity operators. We hope to substantiate this remark in a subsequent\\\\npublication.\\\\n3.2. Definition of rep  . The function eat  allows us to interpret an element of the\\\\ndatatype PA B as a continuous function in A  B  . Now we define a function rep \\\\nthat picks a representative for any such continuous function. In the following subsection,\\\\nwell show that rep  is right-inverse to eat  .\\\\nAs the codomain of rep  is to be the carrier of a final coalgebra for the functor TA (B ),\\\\nwe define rep  as the (unique) coalgebra morphism from a coalgebra for the same functor\\\\n\\\\n\\\\f10\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\nwith carrier A  B  , namely    in the following diagram.\\\\n(A  B  )\\\\n\\\\nrep \\\\n\\\\n/ PA B\\\\n\\\\n\\\\n\\\\n\\\\u000f\\\\n\\\\nTA B  (A  B  )\\\\n\\\\nout\\\\n\\\\n\\\\n\\\\n\\\\u000f\\\\n\\\\nTA (B  (A  B  ))\\\\n\\\\nTA (1rep  )\\\\n\\\\n\\\\u000f\\\\n/ TA (B  PA B)\\\\n\\\\nSo rep  = unfold (   ). Here\\\\n : (A  B  )  TA B  (A  B  )\\\\n f = hrep(hd  f ), tl  f i\\\\nThe other component  of the structure map of our TA  (B)-coalgebra is a fold. (For\\\\nclarity, we give it a more general type than we need.) It is in some sense a fast-forward\\\\noperation.\\\\n : TA B  (A  C)  TA (B  (A  C))\\\\nhRet b, f i = Rethb, f i\\\\nhGet , f i = Get ( a) h a, f  (a #)i\\\\nRemarks:  is actually an isomorphism. It does not change the shape of a tree, but only\\\\ndecorates the data stored at its leaves. So, for example, (0  eat )(t, ) = (0  assoc \\\\neat)((t, f ), ) for any t : TA B and f : A  C.\\\\nAlthough rep cannot be defined constructively, at least without postulating some form\\\\nof bar-induction, the construction of rep  from rep is a simple matter of programming.\\\\n3.3. Completeness of eat  . Now we want to show that the function eat  is surjective.\\\\nIt is enough to show that rep  is a right inverse for eat  .\\\\nTheorem 3.1. (Completeness of representation of A  B  by PA B.)\\\\n(eat   rep  ) = 1A B  .\\\\nProof. We show that the following relation R is a bisimulation on B  , and therefore included\\\\nin the equality relation.\\\\nR = {(f , eat (rep f, )) |  : A , f : A  B  }\\\\nIt is enough to prove that if f : A  B  and  : A , then\\\\n(1) hd (f ) = hd (eat  (rep  f, )), and\\\\n(2) tl (f ) R tl (eat  (rep  f, )).\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n11\\\\n\\\\nAs for (1),\\\\n=\\\\n=\\\\n=\\\\n=\\\\n=\\\\n\\\\nhd (eat  (rep  f, ))\\\\n(0  assoc  eat)(out (rep  f ), )\\\\n(0  assoc  eat)((TA  (B))rep     (rep  1)  hhd , tl i)f, )\\\\n(0  assoc  eat)((TA  (B))rep   )(rep(hd  f ), tl  f ), )\\\\n{(TA  (B))rep    doesnt affect shape, or first coordinate of data }\\\\n(0  eat)(rep(hd  f ), )\\\\n{Completeness in the discrete-valued case }\\\\nhd (f )\\\\n\\\\nAs for (2), we start by expanding definitions.\\\\ntl (eat  (rep  f, ))\\\\n= (eat   1  assoc  eat)((TA  (B))rep   )(rep(hd  f ), tl  f ), )\\\\nWe have to show that that for all f : A  B  and  : A ,\\\\ntl (f ) R (eat   1  assoc  eat)((TA  (B))rep   )(rep(hd  f ), tl  f ), ) .\\\\nBy completeness in the discrete-valued case, it is enough to show that for all t  TA B,\\\\nf  : A  B  and  : A ,\\\\nf  () R (eat   1  assoc  eat)((TA  (B))rep   )(t, f  ), ) .\\\\nWe argue by induction on the wellfounded structure t.\\\\n In the base case that t has the form Ret b, calculation shows that\\\\n(eat   1  assoc  eat )((TA  (B))rep   )(t, f  ), )\\\\n= eat  (rep  (f  ), ) .\\\\nBut (f  ) R eat  (rep  (f  ), )), so we are done with this case.\\\\n In the step case that t has the form Get , calculation shows that\\\\n(eat   1  assoc  eat)((TA  (B))rep   )(t, f  ), )\\\\n= (eat   1  assoc  eat)((TA  (B))rep   )((0 ), f   (0 #),  ) .\\\\nBut by induction hypothesis,\\\\n(f   (0 #))( )\\\\nR (eat   1  assoc  eat )((TA  (B))rep   )((0 ), f   (0 #),  ) ,\\\\nand moreover (f   (0 #))( ) = f  (). So we are done with this case too.\\\\n4. Composition\\\\nIn the previous section we defined a complete representation for continuous functions in\\\\nA  B  ", "Experiment": ", using elements of PA B. As continuous functions are closed under composition,\\\\nif p : PB C represents  : B   C  , and q : PA B represents  : A  B  , then theres\\\\nsome r : PA C that represents   . However, the argument for completeness is less than\\\\nentirely constructive. Can we directly program such an r from p and q? Yes! In fact, in\\\\nat least two different ways, one lazy, or demand driven, and the other greedy, or data\\\\ndriven. The computation is reminiscent of cut-elimination in proof theory, though in this\\\\ncase the objects that interact with each other are infinite, non-wellfounded trees, rather\\\\nthan wellfounded derivation trees.\\\\n\\\\n\\\\f12\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\n4.1. Definition of composition as an operation on representatives. We define (using\\\\ncoiteration) an operation () on representations of stream functions that represents the\\\\ncomposition of those functions, in the sense\\\\neat  (p  q) = eat  p  eat  q\\\\nfor p : PB C and q : PA B.\\\\nFirst, we define a coalgebra  for the functor TA  (C). The carrier will be the product\\\\n\\\\nS = TB (C  PB C)  TA (B  PA B). First, we present the defining equations for  in\\\\npattern-matching format, as they might be written in a functional program. (This means\\\\nthat in the third equation, tbc must have the form Get .) Then we show how to analyse\\\\nthis code into nested structural recursions, and so demonstrate that  is not just a piece of\\\\ncode, but actually a function defined by universal properties of the functors TB and TA .\\\\npreponent\\\\npostponent\\\\n}|\\\\n{ z\\\\n}|\\\\n{\\\\nz\\\\n :TB (C  PB C) TA (B  PA B) TA (C  S)\\\\nh Ret hc, pbc i\\\\n, tab i\\\\n= Ret hc, hout pbc , tab ii\\\\nh Get \\\\n, Ret hb, pab ii = h b, out pab i\\\\nh tbc\\\\n, Get i\\\\n= Get ( a) htbc ,  ai\\\\nNote that in the second equation,  at Get  is defined in terms of  at  b, and hence the\\\\npostponent goes down one step in the outer structural recursion (though the preponent\\\\nmay go up, arbitrarily far).\\\\nIt is routine to tease the recursion into the form of nested structural recursions. The\\\\nouter recursion is on the structure of the postponent TB (C  PB C), with an inner or\\\\nsubordinate recursion on the structure of the preponent TA (B  PA B). To write it down,\\\\nwe use a polymorphic function\\\\nfold : (B  C)  ((A  C)  C)  TA B  C\\\\nfold p g (Ret b) = p b\\\\nfold p g (Get ) = g (( a : A) fold p g (a))\\\\nto express structural recursion over wellfounded trees, or in categorical terms the initiality\\\\nof [Ret|Get] among algebras [p|g] : (B + C A )  C. The definition of  can then be given\\\\nin the form\\\\nhtbc , tab i = fold p g tbc tab\\\\nwhere p : (C  PB C)  TA (B  PA B)  TA (C  S)\\\\np hc, pbc i tab = Rethc, hout pbc , tab ii\\\\ng : (B  TA (B  PA B)  TA (C  S))  TA (B  PA B)  TA (C  S)\\\\ng f = fold (( hb, pab i) f b (out pab )) Get .\\\\nNote that the carrier for the algebra of the outer recursion is the function space TA (B \\\\nPA B)  TA (C  S), while that for the inner recursion is TA (C  S).\\\\nIn this form of composition, priority is given to the postponents desire to produce\\\\noutput. No input is consumed until both the postponent and preponent are reading.\\\\n gives rise to a composition combinator  as follows. First, unfold  : S  PA C. We\\\\ndefine  by precomposition with this unfold.\\\\n : PB C  PA B  PA C\\\\n\\\\np  q = (unfold )hout p, out qi\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n13\\\\n\\\\nWe call  lazy composition, since the internal actions of the composite are the minimum\\\\nnecessary to respond to demand for data.\\\\nAltenkirch and Swierstra noticed that there is another such coalgebra. We present its\\\\ndefinition first in functional programming style, using pattern matching; below we show\\\\nhow the equations can be teased into nested recursions.\\\\n :TB (C  PB C)TA (B  PA B) TA (C  S)\\\\n h tbc\\\\n, Get i\\\\n= Get ( a)  htbc ,  ai\\\\n\\\\n h Get \\\\n, Ret hb, pab ii =  h b, out pab i\\\\n\\\\n h Ret hc, pbc i\\\\n, tab i\\\\n= Ret hc, hout pbc , tab ii\\\\nBecause of the top-to-bottom reading of the equations, it is implicit in the last equation that\\\\ntab has the form Ret(b, pab ). Anthropomorphically, this form of composition gives priority\\\\nto the preponents greedy desire to read input. Whereas with the lazy form, output\\\\nis produced as soon as the postponent is ready, regardless of the form of the preponent,\\\\nin this greedier form of composition no output is produced until both the postponent and\\\\npreponent are writing. We call the composition combinator  to which  gives rise greedy\\\\ncomposition, since the internal actions of the composite are driven by the arrival of data at\\\\nthe input.\\\\nWhat is the mathematical structure of the code for this form of composition? Again, it is\\\\ndefinition by nested recursion. One might think3 that the outer recursion is this time on the\\\\nstructure of the preponent, and the inner recursion on the postponent. In fact, this would\\\\nnot work. In the crucial middle clause (in which the two components communicate), the\\\\npostponent goes down in the structural order, while the preponent may go up, arbitrarily\\\\nfar. A more careful analysis shows that, again, the outer recursion is on the structure of the\\\\npostponent, with subordinate recursions on the structure of the preponent. In fact there\\\\nis little formal difference from our definition of  above, except that the base case of the\\\\nouter recursion uses another inner recursion rather than a simple explicit definition. The\\\\nlocal function p then becomes\\\\np : (C  PB C)  TA (B  PA B)  TA (C  S)\\\\np hc, pbc i = fold (( hb, pab i) Rethc, hout pbc , Rethb, pab iii) Get\\\\nUnfortunately we currently have little of substance to say about how these forms of\\\\ncomposition are related. One might well expect that a pipeline implemented with greedy\\\\ncomposition would be less responsive (i.e. deliver results later) than one expressed with the\\\\nlazy form.\\\\n4.2. Correctness of composition. It remains to prove that the two operations that we\\\\ndefined above really represent composition. This pivots on the uniqueness property of\\\\nunfold . Exploiting the similarity of the definitions for  and  we can state the following\\\\nbasic lemma that applies to both. For the sake of readability, the isomorphism out : PA B \\\\n=\\\\nTA (B  PA B) is left implicit.\\\\nc  {,  } satisfy the following laws:\\\\nLemma 4.1. Both composition operators \\\\nc ab ) (where tab = Ret(b, pab ) in case \\\\nc =  )\\\\nc ab = Ret(c, pbc \\\\nt\\\\n(1) Ret(c, pbc )\\\\nt\\\\nc\\\\nc ab\\\\n(2) (Get )\\\\nRet(b,\\\\npab ) =  b\\\\np\\\\nc a) (where pbc = Get  in case \\\\nc = )\\\\nc\\\\n) = Get (a. pbc \\\\n\\\\n(3) pbc \\\\n(Get\\\\n3As did we, at first.\\\\n\\\\n\\\\f14\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\nProof. By unfolding the definitions. Actually, it is the desired effect of the definitions that\\\\nwe have these properties.\\\\nWe now set up a bisimulation that shows that tbc  pab and tbc  pab really represents\\\\nthe composite eat  (tbc )  eat  (pab ). Again, the isomorphism PA B \\\\n= TA (B  PA B) is left\\\\nimplicit.\\\\nLemma 4.2.\\\\nc ab , ), eat  (pbc , eat  (tab , ))) |   A }\\\\nR = {(eat  (pbc \\\\nt\\\\nc  {,  }.\\\\nis a bisimulation on C  if \\\\nProof. It is enough to prove that\\\\nc ab , )) = hd (eat  (pbc , eat  (tab , )))\\\\n(1) hd (eat  (pbc \\\\nt\\\\nc\\\\n(2) tl (eat  (pbc \\\\ntab , )), tl (eat  (pbc , eat  (tab , )))  R\\\\nfor all pbc  PB C and and all tab  PA B and all   A . The proof relies on the following\\\\nidentities, which are readily derived using Lemma 4.1:\\\\nCase pbc = Ret(c, qbc ).\\\\nc ab , )\\\\nc ab , ) = c # eat  (qbc \\\\nt\\\\neat  (pbc \\\\nt\\\\neat  (pbc , eat  (tab , )) = c # eat  (qbc , eat  (tab , ))\\\\nCase pbc = Get  and tab = Ret(b, tab ).\\\\nc ab , ) = eat  (( b)\\\\nt\\\\nc ab , )\\\\neat  (pbc \\\\nt\\\\neat  (pbc , eat  tab ) = eat  ( b, eat  (tab , )).\\\\nCase tab = Get .\\\\nc a, )\\\\nc ab , ) = eat  (pbc \\\\n\\\\neat  (pbc \\\\nt\\\\neat  (pbc , eat  (tab , a # )) = eat  (pbc , eat  ( a, )).\\\\nc =  now follows by nested structural recursion, the outer induction on\\\\nThe claim for \\\\nthe postponent, the inner induction on the preponent; for  the nesting is reversed.\\\\nCorollary 4.3. Both  and  represent composition, i.e. for all pbc and all tab  PA B\\\\nwe have\\\\nc ab ) = eat  tbc  eat  pab .\\\\neat  (pbc \\\\nt\\\\n\\\\nc  {,  }.\\\\nfor \\\\nProof. Immediate from the fact that R, defined above, is a bisimulation and the fact that\\\\nall bisimulations on a final coalgebra are contained in the diagonal.\\\\n5. ", "Discussion": "Conclusion, related work\\\\nWe have defined computationally natural representations of continuous functions on\\\\nstreams, and proved completeness of these representations for the classically understood\\\\nnotion of continuity. This involved teasing apart the fixed points involved into those that\\\\nare initial and those that are final. We also defined combinators on representations that\\\\nrepresent the composition of the functions they represent.\\\\nWe consider the main point of this paper to be i) a representation of stream processors\\\\nas trees - this ensures that our stream processors are total as opposed to the partial functions\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n15\\\\n\\\\nwhich exist in the Haskell function space A  B  ; ii) a guarantee that all stream processors\\\\ncan be represented by such trees; and iii) a demonstration that these trees are well suited\\\\nto computation  this takes the form of an implementation of the composition of stream\\\\nprocessing functions directly on the representatives themselves.\\\\nThere may also be advantages of a more technical nature. Very often when a function\\\\nis represented by a data structure, such as a wellfounded or infinite tree, the function is\\\\nautomatically memoised  its values for particular arguments are recorded in the data,\\\\nand need not be recomputed if they are needed again. For example, the representation of\\\\nfunctions on finitary inductive types by coinductive trees (in general, final coalgebras for\\\\ncertain rank 2 functors) discovered by Hinze [7] and Altenkirch [1] have this property. The\\\\nsame phenomenon may occur with our representation of stream functions. However their\\\\nwork is concerned with functions on inductive types, as is natural with initial algebras,\\\\nwhereas ours is primarily concerned with functions on coinductive types, which is in the\\\\nopposite direction from the universal maps associated with final coalgebras.\\\\nOur representations are not unique, though different representations of the same function correspond to computationally different behaviour. Interesting further work might be\\\\nto investigate the equivalence relation between representations corresponding to (extensional) equality between the represented functions. The relation is clearly not decidable,\\\\nand may be hyperarithmetic or worse (when the data items consumed and produced are\\\\nnatural numbers).\\\\nAnother question that may deserve further study is to understand and compare the\\\\nrelation between the lazy and greedy forms of composition introduced in section 4. More\\\\ngenerally, it may be worth investigating whether there is a real connection between these\\\\nforms of composition and superficially similar forms of composition in cut-elimination, and\\\\nalgorithmic game theory.\\\\nThe set A of streams of values in a set A is perhaps the simplest example of a final\\\\ncoalgebra, namely for the functor (A), a close relative of the set of natural numbers that\\\\nis an initial algebra for the functor (+1). Final coalgebras are sets of infinite values,\\\\nthat can model storage, communication and other evolving devices. In other work that we\\\\nhope to publish in due course, we have generalised Brouwers representations so as to cover\\\\ncontinuous functions between structures of other coinductive types than streams, that is to\\\\nfinal coalgebras for a useful class of functors beyond (A). Broadly the same results can\\\\nbe obtained as for the stream case, though the generalisation involves more mathematical\\\\nmachinery. The mathematical techniques involve working with indexed families of sets,\\\\nusing an inductive-recursive definition (of such an indexed family) in a crucial way.\\\\nIt may be possible to extend these techniques yet further to explore representations of\\\\ncontinuous functions on final coalgebras for finitary indexed containers, that are endofunctors on slice categories. Some preliminary investigations suggest that this might be rather\\\\nlaborious. On the other hand, it could well be worthwhile. Endofunctors of that kind would\\\\nallow us to model non-wellfounded proofs, and so connect our work with Mints continuous\\\\ncut-elimination [13], analysed by Buchholz in [3]. Another connection that might be made\\\\nis with Brotherston and Simpsons non-wellfounded proof systems in [2]. Yet another is\\\\nwith Niwi \\\\nnski and Walukiewiczs infinitary proof trees in [15].\\\\nStream processing is a very venerable approach to systems design. Streams were used\\\\nin a central way in the OS6 operating system of Stoy and Strachey [16], as well as in\\\\ncommercial operating systems. The Unix piping system, introduced by McIlroy, is stream\\\\nbased, with buffering handled by the system. In practical programming, a stream facility is\\\\n\\\\n\\\\f16\\\\n\\\\nP. HANCOCK, D. PATTINSON, AND N. GHANI\\\\n\\\\noften based on something more complicated than a mathematical stream (involving perhaps\\\\nEOF, length, buffering, bounds, putback, ...). These more feature-full streams inhabit\\\\ncoinductive types for more elaborate functors than (A), but they are not substantially\\\\ndifferent.\\\\nThe earliest form of IO in functional programming languages was stream based [12]:\\\\na executable program was a (possibly asynchronous) stream processor. Experience quickly\\\\nshowed it is easy to make mistakes in programs using asynchronous interfaces. Mature\\\\nimplementations of IO interfaces are therefore based on synchronous processing, consuming response streams to produce request streams, in a productive or contractive fashion.\\\\nSome early functional operating systems [11] also used streams (sometimes in a ring) for\\\\ncommunication among system processes.\\\\nThe programming system Fudgets [14] is based on a representation of stream processors\\\\nsimilar to the one in this paper, but without our separation of final from initial fixed\\\\npoints. Fudgets are a language for asynchronous stream processing. Various combinators\\\\nare available for building up stream processors. Implementations of Fudgets with Haskell\\\\nhave been used to build powerful user interaction (mouse, keyboard, display) interfaces. The\\\\nprogramming system Yampa [9], which has been used to produce code for robots (among\\\\nother things) uses a synchronous dataflow metaphor, that is well aligned with classical\\\\ncontrol theory, with its signal processors and feedback loops.\\\\nIt seems obvious that the semantics of feedback loops involves fixpoints, so it may be\\\\nnatural to focus on contractive functions, because of Banachs fixed point theorem (see the\\\\nreferences in the paper [3]). This states that contractive functions have unique fixed points.\\\\nIn their paper Ensuring streams flow [19] Turner and Telford have analysed a productivity\\\\nrequirement for ensuring unique solutions of recursion equations. Productivity seems to be\\\\nclosely related to contractive functions. From another perspective, Buchholz has designed a\\\\ncalculus for writing (recursive) stream processing functions, (and even functions processing\\\\ncertain not-well-founded trees) which ensures that functions are contractive where required\\\\n[3]. We have not specifically examined the representation of contractive functions, though\\\\nthey are prominent in the form of the functions (0 #) in our constructions. Nor have we\\\\nyet considered representations of uniformly continuous functions.\\\\nThe notion of arrow, introduced to functional programming by Hughes [10] was developed to express compositional infrastructure in programming generalising that of Kleisli\\\\nmorphisms for a monad, and crucially interacting with a tensor combinator according to\\\\nsome reasonable laws. The reference [6] provides a useful perspective. Abstractly, an arrow\\\\nis a monoid in a certain category of bifunctors. Our stream processors behave quite well\\\\nwith respect to composition (), but it is not clear to us how nicely they play with operators\\\\nsuch as +,  and other multi-input combinators. It may be that one has to get to grips\\\\nwith notions of fairness, such as fair merging, in connection with such combinators. Another direction for further development is to investigate combinations of stream processors\\\\nin which, as in many applications of stream processing, there are forms of feedback, or\\\\nlooping.\\\\nAcknowledgments. Our colleagues Altenkirch and Swierstra have in unpublished work considered the broad topic of modelling impure (effectful) phenomena such as teletype IO [5],\\\\nmutable heap variables and multithreading. We are grateful to them for interesting conversations on the topic of stream IO, and in particular for pointing out (and debugging) the\\\\ngreedy form of composition mentioned in section 4. Their model of teletype IO in [17],\\\\n\\\\n\\\\fSTREAM PROCESSORS USING NESTED FIXED POINTSSHORT TITLE\\\\n\\\\n17\\\\n\\\\nwhile close to that expounded in this paper, does not address productivity and continuity. Finally we thank the referees for their close scrutiny of the paper, and many valuable\\\\nsuggestions.\\\\nReferences\\\\n[1] T. Altenkirch. Representations of first order function types as terminal coalgebras. In Typed Lambda\\\\nCalculi and Applications, TLCA 2001, number 2044 in Lecture Notes in Computer Science, pages 8 \\\\n21, 2001.\\\\n[2] J. Brotherston and A. Simpson. Complete sequent calculi for induction and infinite descent. In Proceedings of LICS-22, pages 5160. IEEE Computer Society, July 2007.\\\\n[3] W. Buchholz. A term calculus for (co-)recursive definitions on streamlike data structures. Ann. Pure\\\\nAppl. Logic, 136(1-2):7590, 2005.\\\\n[4] M. Dummett. Elements of intuitionism. Clarendon Press, Oxford, 2000. 2nd edition.\\\\n[5] A. D. Gordon. Functional programming and input/output. Cambridge University Press, New York, NY,\\\\nUSA, 1994.\\\\n[6] C. Heunen and B. Jacobs. Arrows, like monads, are monoids. Electronic Notes in Theoretical Computer\\\\nScience, 158:219236, May 2006.\\\\n[7] R. Hinze. Memo functions, polytypically! In J. Jeuring, editor, Proceedings of the 2nd Workshop on\\\\nGeneric Programming, Ponte de Lima, Portugal, pages 1732, jul 2000. The proceedings appeared as a\\\\ntechnical report of Universiteit Utrecht, UU-CS-2000-19.\\\\n[8] W. A. Howard and G. Kreisel. Transfinite induction and bar induction of types zero and one, and the\\\\nrole of continuity in intuitionistic analysis. J. Symb. Log., 31(3):325358, 1966.\\\\n[9] P. Hudak, A. Courtney, H. Nilsson, and J. Peterson. Arrows, robots, and functional reactive programming. In Summer School on Advanced Functional Programming 2002, Oxford University, volume 2638\\\\nof Lecture Notes in Computer Science, pages 159187. Springer-Verlag, 2003.\\\\n[10] J. Hughes. Generalising monads to arrows. Science of Computer Programming, 37(1-3):67111, May\\\\n2000.\\\\n[11] S. B. Jones and A. F. Sinclair. Functional programming and operating systems. Comput. J., 32(2):162\\\\n174, 1989.\\\\n[12] P. J. Landin. Correspondence between algol 60 and churchs lambda-notation: part i. Commun. ACM,\\\\n8(2):89101, 1965.\\\\n[13] G. Mints. Finite investigations of transfinite derivations. J. Sov. Math., 10, 1978.\\\\n[14] A. K. Moran, D. Sands, and M. Carlsson. Erratic Fudgets: A semantic theory for an embedded coordination language. In Coordination 99, volume 1594 of Lecture Notes in Computer Science. Springer-Verlags,\\\\nApr. 1999.\\\\n[15] D. Niwi \\\\nnski and I. Walukiewicz. Games for the -calculus. Theor. Comput. Sci., 163(1-2):99116, 1996.\\\\n[16] J. E. Stoy and C. Strachey. Os6 - an experimental operating system for a small computer. part 1:\\\\ngeneral principles and structure. Comput. J., 15(2):117124, 1972.\\\\n[17] W. Swierstra and T. Altenkirch. Beauty in the beast: A functional semantics of the awkward squad. In\\\\nHaskell 07: Proceedings of the ACM SIGPLAN Workshop on Haskell, pages 2536, 2007.\\\\n[18] W. W. Tait. Constructive reasoning. In B. V. Rootselaar and J. Staal, editors, Logic, Methodology\\\\nand Philosophy of Science III, Studies in Logic and the Foundations of Mathematics, pages 185200,\\\\nAmsterdam, 1968. North-Holland.\\\\n[19] A. Telford and D. Turner. Ensuring streams flow. In Algebraic Methodology and Software Technology,\\\\npages 509523, 1997.\\\\n[20] A. Troelstra and D. van Dalen. Constructivism in Mathematics. North-Holland, 1988. 2 volumes.\\\\n[21] D. Turner. Total functional programming. Journal of Universal Computer Science, 10(7):751768, 2004.\\\\n\\\\nThis work is licensed under the Creative Commons Attribution-NoDerivs License. To view\\\\na copy of this license, visit http://\\\\nreative\\\\nommons.org/li\\\\nenses/by-nd/2.0/ or send a\\\\nletter to Creative Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or\\\\nEisenacher Strasse 2, 10777 Berlin, Germany\\\\n\\\\n\\\\f\"}\\n'"}, "key_words": {"Abstract": [["computing", 0.4858], ["computer science university", 0.4616], ["computer science nvol", 0.4497], ["logical methods computer", 0.4307], ["methods computer", 0.4072]], "Introduction": [["represent continuous functions", 0.4856], ["represents ncontinuous function", 0.484], ["streams continuous functions", 0.4813], ["implementation continuous nfunctions", 0.4774], ["functions standard mathematical", 0.4653]], "Related Work": [["coinductive definitions", 0.6631], ["coinductive definitions nested", 0.6409], ["coinductive types", 0.6358], ["coinductive structures", 0.6187], ["consider general coinductive", 0.6118]], "Methodology": [["infinite uncountably nrepresentatives", 0.5333], ["functions nrepresentatives", 0.5153], ["uncountably nrepresentatives", 0.5135], ["representative functions", 0.4835], ["uncountably nrepresentatives nproof", 0.4768]], "Experiment": [["functional programming", 0.4985], ["wellfounded derivation trees", 0.4967], ["derivation trees f12", 0.4911], ["structural recursions demonstrate", 0.4837], ["derivation trees", 0.483]], "Discussion": [["representation stream functions", 0.591], ["functions constructions", 0.561], ["represented functions", 0.5556], ["processing functions", 0.5541], ["stream processing functions", 0.548]]}, "summarization": {"Abstract": "we define representations of continuous functions on infinite streams of discrete values. We use Nested to represent stream-valued functions. The idea can be traced to Brouwers justification of bar-induction and elimination of choice-sequences.   Logical Methods in Computer Science, Vol. 5, 2009.", "Introduction": "continuous functions are functions on spaces of infinite sequences or streams of discrete values. We show how to represent a continuous function in terms of a well-founded tree branching over a discrete space. The tree represents a function in the form of a stream of binary digits or natural numbers.", "Related Work": "design of formalisms for systems for developing dependently typed programs. paper describes a way of constructing streams and lists in Haskell. The paper includes a proof of completeness for the idea of coinductive-recursive definition of a stream of natural numbers. the paper also describes how to construct streams using hd and tl- notation.", "Methodology": "definition of the definition of a stream-valued function. We show that a continuous function of type A  B is not continuous in the strong inductive sense. We prove that the definition is a proof of the Churchs thesis. The proof is based on the axiom of dependent choices.", "Experiment": ", using elements of PA B. We show how to express structural recursion over wellfounded trees. We analyse the recursion in the form of nested structural recursions. The recursion is written in terms of a linear algebra of the functors TB and TA  \u00a0.", "Discussion": "We prove that continuous functions on streams can be represented by natural representations of stream processors. We also show that these representations can be used to represent the composition of stream functions. The paper is a proof of completeness for the notion of continuity. We have also developed a generalisation of the proof to other structures."}}