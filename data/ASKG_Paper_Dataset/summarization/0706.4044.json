{
  "sections": {
    "Abstract": "b'{\"search-keyword: clean-text| displaying exact matches\":\"arXiv:0706.4044v1 [cs.LO] 27 Jun 2007\\\\n\\\\nPSPACE Bounds for Rank-1 Modal Logics\\\\n \\\\nLUTZ SCHRODER\\\\nDFKI-Lab Bremen and Dept. of Comput. Sci., Universit at Bremen\\\\nand\\\\nDIRK PATTINSON\\\\nDepartment of Computing, Imperial College London\\\\n\\\\nFor lack of general algorithmic methods that apply to wide classes of logics, establishing a complexity bound for a given modal logic is often a laborious task. The present work is a step towards\\\\na general theory of the complexity of modal logics. Our main result is that all rank-1 logics enjoy\\\\na shallow model property and thus are, under mild assumptions on the format of their axiomatisation, in PSPACE . This leads to a unified derivation of tight PSPACE -bounds for a number\\\\nof logics including K, KD, coalition logic, graded modal logic, majority logic, and probabilistic\\\\nmodal logic. Our generic algorithm moreover finds tableau proofs that witness pleasant prooftheoretic properties including a weak subformula property. This generality is made possible by a\\\\ncoalgebraic semantics, which conveniently abstracts from the details of a given model class and\\\\nthus allows covering a broad range of logics in a uniform way.\\\\nCategories and Subject Descriptors: F.4.1 [Mathematical Logic and Formal Languages]:\\\\nMathematical LogicModal Logic; Computational Logic; F.2.2. [Analysis of Algorithms and\\\\nProblem Complexity]: Nonnumerical Algorithms and ProblemsComplexity of Proof Procedures\\\\nGeneral Terms: Algorithms, Languages, Theory\\\\nAdditional Key Words and Phrases: Shallow models, resolution, coalgebra\\\\n\\\\n1. INTRODUCTION\\\\nModal logics are attractive from a computational point of view, as they often combine expressiveness with decidability. For many modal logics not involving dynamic features, satisfiability is known to be in PSPACE . This is typically proved\\\\nfor one logic at a time, e.g. by modifications of the witness algorithm for the\\\\nmodal logic K [Ladner 1977; Blackburn et al. 2001], but also using markedly different methods such as the constraint-based PSPACE -algorithm for graded modal\\\\nlogic [Tobies 2001]. Vardi [1989] gives a first glimpse of a generalisable method,\\\\nequipping various epistemic logics with a neighbourhood frame semantics and showing them to be in NP and PSPACE , respectively (with the K axiom being responsible for PSPACE -hardness; recent work by Halpern and Rego [2007] shows that\\\\nnegative introspection brings the complexity back down to NP). Nevertheless, there\\\\nis to date no generally applicable theorem that allows establishing PSPACE -bounds\\\\nfor large classes of modal logics in a uniform way.\\\\nHere, we generalise the methods of [Vardi 1989] to obtain PSPACE bounds for\\\\nrank-1 modal logics, i.e. logics axiomatisable by formulas whose modal depth uniformly equals one, in a systematic way. Although presently limited to rank 1, our\\\\napproach covers numerous relevant and non-trivial examples. We recover known\\\\nPSPACE bounds not only for normal modal logics such as K and KD, but most\\\\nnotably also for a range of non-normal modal logics such as graded modal logic [Fine\\\\n\\\\n\\\\f2\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\n1972], coalition logic [Pauly 2002], and probabilistic modal logic [Larsen and Skou\\\\n1991; Heifetz and Mongin 2001]. Moreover, our methods lead to a previously unknown PSPACE upper bound for majority logic [Pacuit and Salame 2004] that\\\\nwas independently discovered by Demri and Lugiez [2006] at the same time. These\\\\nlogics are far from exotic: graded modal logic plays a role e.g. in decision support and knowledge representation [van der Hoek and Meyer 1992; Ohlbach and\\\\nKoehler 1999], and probabilistic modal logic has appeared in connection with model\\\\nchecking [Larsen and Skou 1991] and in modelling economic behaviour [Heifetz and\\\\nMongin 2001].\\\\nThe key to such a degree of generality is to parametrise the theory over the type\\\\nof systems defining the semantics, using coalgebraic methods. Coalgebra conveniently abstracts from the details of a concrete class of models as it encapsulates\\\\nthe precise nature of models in an endofunctor on the category of sets. As specific instances, one obtains e.g. (serial) Kripke frames, (monotone) neighbourhood\\\\nframes [Hansen and Kupke 2004], game frames [Pauly 2002], probabilistic transition systems and automata [Rabin 1963; Bartels et al. 2004], weighted automata,\\\\nlinear automata [Carlyle and Paz 1971], and multigraphs [DAgostino and Visser\\\\n2002]. Despite the broad range of systems covered by the coalgebraic approach,\\\\na substantial body of concepts and non-trivial results has emerged, encompassing\\\\ne.g. generic notions of bisimilarity and coinduction [Bartels 2003], corecursion [Turi\\\\nand Plotkin 1997], duality, and ultrafilter extensions [Kupke et al. 2005]. On the\\\\napplications side, coalgebraic modal logic features in actual specification languages\\\\nsuch as the object oriented specification language CCSL [Rothe et al. 2001] and\\\\nCoCasl [Mossakowski et al. 2006].\\\\nThe coalgebraic study of computational aspects of modal logic was initiated\\\\nin [Schr oder 2007], where the finite model property and associated NEXPTIME bounds were proved. Here, we push these results further and present a shallow\\\\nmodel property based on coalgebraic semantics. This leads to a generic PSPACE algorithm for deciding satisfiability that traverses a shallow model and strips off\\\\none layer of modalities in every step. Alternatively, our algorithm may be seen as\\\\ncomputing a shallow proof that enjoys a number of pleasant proof-theoretic properties, including a weak subformula property (i.e. it mentions only propositional\\\\ncombinations of subformulas of the goal).\\\\nThe model construction relies on extending the axiomatisation of a given logic\\\\nto a set of rules which is closed under rule resolution, i.e. every resolvent of two\\\\nsubstituted rule conclusions can also be derived directly using a third rule. This\\\\nprocess typically results in an infinite but recursive set of rules. Resolution closedness then enables us to build the shallow model using induction on the modal depth\\\\nof formulas. Since we are working with an infinite set of rules, we have to impose\\\\na second condition to ensure that we can decide satisfiability: a rule set is closed\\\\nunder contraction if every substituted rule conclusion with duplicate literals can\\\\nbe derived using a substitution instance of a second rule in whose conclusion all\\\\nliterals remain distinct. The decision procedure will run in PSPACE if both closure under resolution and closure under contraction can be controlled, i.e. there is\\\\na polynomial bound on the size of rules that are applicable at every step of the\\\\ndeductive process. This turns out to be the case for all examples mentioned above.\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n3\\\\n\\\\nThe material is organised as follows. In Section 2, we give a brief introduction to\\\\nthe generic coalgebraic semantics of modal logic. In Section 3, we discuss deduction\\\\nsystems for coalgebraic modal logics and their properties, notably the (equivalent)\\\\ncentral notions of strict one-step completeness and reduction closedness of rule sets.\\\\nSections 4 and 5 are devoted to the tableau-based shallow model construction and\\\\nthe proof-theoretic view thereof. The ensuing PSPACE -algorithm and its example\\\\napplications are presented in Section 6.\\\\n2. COALGEBRAIC MODAL LOGIC\\\\nWe briefly recapitulate the basics of the coalgebraic interpretation of modal logic.\\\\nTo begin, we fix the syntactic framework. A modal signature is just a set  of\\\\nunary modal operators (all our results generalise straightforwardly to a polyadic\\\\nsetting as in [Schr oder 2005]). The signature  induces a modal language F (),\\\\nwith formulas ,   F () defined by the grammar\\\\n ::=  |    |  | L,\\\\nwhere L ranges over . Disjunctions   , truth , and other boolean operations\\\\nare defined as usual. The depth of a formula is its maximal nesting depth of modal\\\\noperators.\\\\nWe work in the framework of coalgebraic modal logic, introduced by Pattinson\\\\n[2004], generalising previous results [Jacobs 2000; R \\\\noiger 2000; Kurz 2001; Pattinson 2001], where modal languages are interpreted over coalgebras for a Set-functor:\\\\nDefinition 2.1. [Rutten 2000] Let T : Set  Set be a functor, referred to as the\\\\nsignature functor, where Set is the category of sets. A T -coalgebra A = (X, ) is\\\\na pair (X, ) where X is a set (of states) and  : X  T X is a function called the\\\\ntransition function. A morphism f : A  B between T -coalgebras A = (X, ) and\\\\nB = (Y, ) is a map f : X  Y such that T f  = f .\\\\nWe view coalgebras as generalised transition systems: the transition function delivers a structured set of successors and observations for a state. Mutatis mutandis,\\\\nwe can in fact allow T to take proper classes as values, as we never iterate T or\\\\notherwise assume that T X is a set; details are left implicit. This allows us to treat\\\\nmore examples, in particular Paulys coalition logic (Example 2.7.8 below).\\\\nAssumption 2.2. We can assume w.l.o.g. that T preserves injective maps [Barr\\\\n1993]. For convenience of notation, we will in fact sometimes assume that T X  T Y\\\\nin case X  Y . Moreover, we assume w.l.o.g. that T is non-trivial, i.e. T X =  =\\\\nX =  (otherwise, T X =  for all X).\\\\nDefinition 2.3. If for a subset Z  X of a coalgebra A = (X, ),  restricts to\\\\na map Z : Z  T Z, then C = (Z, Z ) is a subcoalgbra of A; in this case, the\\\\ninclusion Z  X is a morphism C  A.\\\\nIn the same way that the signature functor abstracts from a concrete class of\\\\nmodels, the interpretation of modal operators is encapsulated in terms of predicate\\\\nliftings:\\\\nDefinition 2.4. A predicate lifting for a functor T is a natural transformation\\\\nQ  Q  T op ,\\\\n\\\\n\\\\f4\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nwhere Q denotes the contravariant powerset functor Setop  Set (i.e. Q(X) =\\\\nP(X) is the powerset, and Qf (B) = f 1 [B] for f : X  Y and B  Q(X)).\\\\nA coalgebraic semantics for a modal signature  is given by a -structure, consisting\\\\nof a signature functor T and an assignment of a predicate lifting [[L]] for T to every\\\\nmodal operator L  ; by abuse of notation, we refer to the entire -structure just\\\\nas T . Given a -structure T , the satisfaction relation |=C between states x of a\\\\nT -coalgebra C = (X, ) and F ()-formulas is defined inductively, with the usual\\\\nclauses for the boolean operations. The clause for the modal operator L is\\\\nx |=C L  (x)  [[L]]C ([[]]C ),\\\\nwhere [[]]C = {x  X | x |=C }. We drop the subscripts C when these are clear\\\\nfrom the context.\\\\nWe occasionally make use of the fact that the logic F () is adequate for T coalgebras [Pattinson 2004]:\\\\nProposition 2.5. If f : A  B is a morphism of T -coalgebras, then\\\\nx |=A \\\\n\\\\niff\\\\n\\\\nf (x) |=B \\\\n\\\\nfor all states x in A and all F ()-formulas .\\\\nOur main interest here is in the local satisfiability problem:\\\\nDefinition 2.6. An F ()-formula  is satisfiable (over T ) if there exist a T coalgebra A = (X, ) and a state x in X such that x |=A . Dually,  is valid\\\\nif x |=A  for all T -coalgebras A = (X, ) and all x  X.\\\\nExample 2.7. [Pattinson 2004; Crstea and Pattinson 2007; Schr oder 2007] We\\\\nillustrate how the coalgebraic approach subsumes a large class of modal logics.\\\\nThis includes not only logics with a standard Kripke semantics, but in particular\\\\nalso non-normal modal logics whose semantics is defined over structures that differ\\\\nsubstantially from classical Kripke frames.\\\\n(1) Modal logic K: The signature K of the modal logic K consists of a single\\\\nmodal operator . Let P be the covariant powerset functor. Then P-coalgebras are\\\\ngraphs, thought of as transition systems or indeed Kripke frames. A K -structure\\\\nover P is defined by\\\\n[[]]X (A) = {B  P(X) | B  A};\\\\nthis induces precisely the standard Kripke semantics of modal logic (note that no\\\\nrestrictions are imposed on frames).\\\\n(2) Modal logic KD: KD is obtained from K by adding the axiom , i.e.\\\\nby restricting the semantics to serial Kripke frames (X, R), characterized by the\\\\ncondition that for every state x, there exists a state y such that xRy. Thus, the\\\\nsignature KD of the normal modal logic KD is the same as that of K, and a KD structure is defined in the same way as for K, but over the non-empty powerset\\\\nfunctor P  defined by P  (X) = {A  P(X) | A 6= }.\\\\n(3) Modal logic E: The signature E of the modal logic E, the smallest classical modal logic [Chellas 1980], has a single modal operator ; the proof system of\\\\nE comprises, besides propositional reasoning, only replacement of equivalents (i.e.\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n5\\\\n\\\\nthe rule a  b/a  b). The standard neighbourhood semantics of E is coalgebraically captured by a E -structure over the neighbourhood functor N = Q  Qop\\\\n(composition of the contravariant powerset functor with itself); coalgebras for this\\\\nfunctor are neighbourhood frames. The modal operator  is interpreted over N by\\\\n[[]]X (A) = {  N (X) | A  }.\\\\n(4) Modal logic M : The modal logic M , the smallest monotonic modal\\\\nlogic [Chellas 1980], is obtained from the modal logic E by adding the monotonicity rule a  b/a  b. The neighbourhood semantics of M is captured\\\\ncoalgebraically analogously to the previous example as a structure over the subfunctor UpP of N assigning to a set X the set of upwards closed subsets of QX.\\\\nCoalgebras for UpP are monotone neighbourhood frames [Hansen and Kupke 2004].\\\\n(5) Graded modal logic [Fine 1972]: The modal signature of graded modal logic\\\\n(GML) is GML = {k | k  N}; the intended reading of k  is  holds in more\\\\nthan k successor states. The semantics of GML is originally defined by counting successor states in Kripke frames. This semantics fails to be coalgebraic, as\\\\nthe naturality condition for the associated predicate liftings fails. However, one\\\\nmay define a coalgebraic semantics which is equivalent for purposes of satisfiability [Schr oder 2007], as follows. The finite multiset (or bag) functor B maps a set X\\\\nto the set of maps B : X  N with finite support, the intuition being that B is\\\\na multiset containing\\\\nx  X with multiplicity B(x). We extend B to P(X) by\\\\nP\\\\nputting B(A) = xA B(x). The action on morphisms f : X  Y is then given by\\\\nBf : BX  BY, B 7 y. B(f 1 [{y}]). Coalgebras for B are directed graphs with\\\\nN-weighted edges, often referred to as multigraphs [DAgostino and Visser 2002].\\\\nThe graded modal operator k is intepreted over B by\\\\n[[k ]]X (A) = {B : X  N  B(X) | B(A) > k}.\\\\nThus, x \\\\u000f k  for a state x in a B-coalgebra iff  holds for more than k successor\\\\nstates of x, taking into account multiplicities.\\\\nThe dual operators k  are denoted \\\\u0003k , i.e. \\\\u0003k  reads  fails in at most k\\\\nsuccessor states. Note that \\\\u0003k is monotone, but fails to be normal unless k = 0. A\\\\nnon-monotone variation of GML arises when negative multiplicities are admitted.\\\\n(6) Majority logic [Pacuit and Salame 2004]: Graded modal logic is extended to\\\\nmajority logic by adding a weak majority operator W , read in at least half of the\\\\nsuccessor states, it is the case that . . . . The structure for GML over the multiset\\\\nfunctor B described in the previous example is extended to W by putting\\\\n[[W ]]X (A) = {B : X  N  B(X) | B(A)  B(X  A)}.\\\\nThe dual operator M = W  captures strict majority in more than half of the\\\\nsuccessor states, it is the case that.\\\\n(7) Probabilistic modal logic [Larsen and Skou 1991; Heifetz and Mongin 2001]:\\\\nThe modal signature PML of probabilistic modal logic (PML) comprises operators Lp , p  [0, 1]  Q, to be read in the next step, it is with probability at least p\\\\nthe case that. . . . We define a PML -structure over the finite distribution functor D which maps a set X to the set of probability distributions on X with finite\\\\n\\\\n\\\\f6\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nsupport. Coalgebras for D are probabilistic transition systems (also called probabilistic type spaces [Heifetz and Mongin 2001]) with finite branching degree. Our\\\\ndefinition contrasts with that of [Heifetz and Mongin 2001], where there is no restriction on the branching degree, but since PML has the finite model property (cf.\\\\nloc. cit.), this has no bearing on satisfiability. The interpretation of Lp over D is\\\\ndefined by\\\\n[[Lp ]](A) = {P  D X | P A  p}.\\\\nPML is non-normal (Lp (a  b)  Lp a  Lp b is not valid for p > 0).\\\\n(8) Coalition logic [Pauly 2002]: Let N = {1, . . . , n} be a fixed set of agents.\\\\nSubsets of N are called coalitions. The signature Coal of coalition logic consists\\\\nof modal operators [C], where C ranges over coalitions, read coalition C has a\\\\ncollaborative strategy to ensure that . . . . A coalgebraic semantics for coalition\\\\nlogic is based on the class-valued signature functor T defined by\\\\nQ\\\\nT X = {(S1 , . . . , Sn , f ) |  6= Si  Set, f : iN Si  X}.\\\\n\\\\nThe elements of T X are understood as strategic games with set X of states, i.e.\\\\ntuples consisting\\\\nof nonempty sets Si of strategies for all agents i, and an outcome\\\\nQ\\\\nfunction\\\\n(\\\\nS\\\\n)\\\\n\\\\nX. A T -coalgebra is a game frame [Pauly 2002]. We denote the\\\\ni\\\\nQ\\\\nfor C  SC , C   SC  , where C  = N  C, (C , C  ) denotes\\\\nset iC Si by SC , andQ\\\\nthe obvious element of iN Si . A Coal -structure over T is then defined by\\\\n[[[C]]]X (A) = {(S1 , . . . , Sn , f )  T X | C  SC . C   SC  . f (C , C  )  A}.\\\\n\\\\nAll the above examples can be canonically extended to systems that process\\\\ninputs from a set I by passing from the signature functor T to one of the functors T I\\\\nor T (I  ) and suitably indexing the modal operators. We refer to [Crstea and\\\\nPattinson 2007] for a detailed account of the induced logics.\\\\nRemark 2.8. In the modal grammar given above, atomic propositional symbols\\\\nare deliberately not included. This is for the sake of both generality, as some\\\\nmodal logics such as Hennessy-Milner logic do not include such atomic propositions,\\\\nand economy of presentation, as a set U of atomic propositional symbols may be\\\\nintegrated in the basic framework as follows. Given a modal signature  and a\\\\n-structure T , we define a structure for the modal signature U =   U over the\\\\nfunctor TU defined by TU X = T X  P(U ): modal operators from  are interpreted\\\\nby taking the preimage of their interpretation over T under the projection TU  T ,\\\\nand a propositional symbol a  U is interpreted by putting\\\\n[[a]]X (A) = {(t, B)  T X  P(U ) | a  B}.\\\\nSince [[a]] is independent of its argument, the modal operator a can be written as\\\\njust the propositional symbol a (without an argument formula). In a framework\\\\nwith polyadic modal operators [Schr oder 2005], propositional constants correspond\\\\nto nullary modalities. Some of the logics above indeed require propositional symbols\\\\nlest they collapse into triviality. This holds in those cases where T 1 (for 1 a singleton\\\\nset) is a singleton, e.g. probabilistic modal logic, coalition logic, and the modal\\\\nlogic KD. We nevertheless generally continue to omit the treatment of propositional\\\\nsymbols in the sequel, since the addition of propositional symbols as indicated above\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n7\\\\n\\\\nhas no bearing on the rule sets forming the core of our method, and the model\\\\nconstruction is entirely analogous.\\\\n3. PROOF SYSTEMS FOR COALGEBRAIC MODAL LOGIC\\\\nOur decision procedure for rank-1 logics relies on a complete axiomatisation in a\\\\ncertain format. Deduction for modal logics with coalgebraic semantics has been\\\\nconsidered in [Pattinson 2003; Crstea and Pattinson 2007; Kupke et al. 2005;\\\\nSchr oder 2007]. It has been shown that every modal logic over coalgebras can be\\\\naxiomatised in rank 1 using either rank-1 axioms or rules leading from rank 0 to\\\\nrank 1 [Schr oder 2007], essentially because functors, as opposed to comonads, only\\\\nencode the one-step behaviour of systems. Here, we focus on rules. The crucial\\\\ningredients for the shallow model construction and the ensuing PSPACE algorithm\\\\nare novel notions of resolution closure and strict one-step completeness of rule sets.\\\\nFor the remainder of the paper, we fix a modal signature  and a -structure T .\\\\nWe recall a few basic notions from propositional logic, as well as notation for coalgebraic modal logic introduced in [Pattinson 2003; Crstea and Pattinson 2007]:\\\\nDefinition 3.1. We denote the set of propositional formulas over a set V (consisting e.g. of propositional variables or modal formulas) by Prop(V ). Here, we\\\\nregard  and  as the basic connectives, with all other connectives defined in the\\\\nstandard way. For ,   Prop(V ), we say that  propositionally entails  and write\\\\n PL  if    is a propositional tautology. Similarly,   Prop(V ) propositionally entails  ( PL ) if there exist 1 , . . . , n   such that 1      n PL .\\\\nA literal over V is either an element of V or the negation of such an element. We\\\\nuse the meta-variable o (possibly indexed) to denote either nothing or , so that a\\\\nliteral over V has the general form oa, a  V . A clause\\\\nWn is a finite (possibly empty)\\\\ndisjunction of literals, which then takes the form i=1 oi ai with a1 , . . . , an  V .\\\\nSimilarly, a conjunctive clause is a finite conjunction of literals. A (conjunctive)\\\\nclause is contracted if all its literals are distinct. The set of all clauses over V\\\\nis denoted by Cl(V ). Although we regard clauses as formulas rather than sets of\\\\nliterals, we shall sometimes use terminology such as a literal is contained in a\\\\nclause or a clause contains another, with the obvious meaning. We denote by\\\\nUp(V ) the set {La | L  , a  V }.\\\\nIf V consists of propositional variables, then we have the usual notions of valuation and substitution: A valuation is just a map  : V  {, } assigning boolean\\\\ntruth values to variables; for   Prop(V ), we write  |=  if  is a satisfying\\\\nvaluation for . More generally, given a set X, a P(X)-valuation for V is a map\\\\nV  P(X). For   Prop(V ), a P(X)-valuation  induces in the obvious way a\\\\nsubset [[]] of X; we write X,  |=  if [[]] = X. Using the structure T for , we\\\\ninterpret   Prop(Up(V )) as a subset [[]] of T X by putting [[L]] = [[L]][[]] ,\\\\nand we write T X,  |=  if [[]] = T X. Moreover, given a set Z, a Z-substitution\\\\nfor V is a map  : V  Z; for a formula  over V (e.g.   Prop(Up(Prop(V )))),\\\\nwe denote the result of performing the substitution  on  by  and refer to \\\\nas a Z-instance of .\\\\nLemma 3.2. For ,   Cl(V ),  PL  iff either  is contained in  or  is a\\\\ntautology (i.e. contains both a and a for some a  V ).\\\\n\\\\n\\\\f8\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nDefinition 3.3. A (one-step) rule R over a set V of propositional variables is\\\\na rule /, where   Prop(V ) and   Cl(Up(V )). We silently identify rules\\\\nmodulo -equivalence. The rule R is sound if, whenever  is valid for an F ()substitution , then  is valid. Moreover, R is one-step sound if T X,  |=  for\\\\neach set X and each P(X)-valuation  such that X,  |= .\\\\nOur hitherto informal use of the term rank-1 logic formally means axiomatisable\\\\nby one-step rules. The term rank-1 logic has been used in the literature [Pattinson\\\\n2003; Crstea and Pattinson 2007; Kupke et al. 2005; Schr oder 2007] to describe\\\\nlogics axiomatisable by rank-1 axioms, i.e. propositional combinations of formulas L where L is a modal operator and  is purely propositional (in the notation\\\\nintroduced above, formulas from Prop(Up(Prop(V )))). This class of axioms includes\\\\ne.g. the K axiom (a  b)  (a  b), but excludes axioms containing nested\\\\nmodalities or top-level propositional variables such as the axioms 4 and T , respectively. It has been shown in [Schr oder 2007] that one-step rules and rank-1 axioms\\\\ndetermine the same class of logics.\\\\nRemark 3.4. We can always assume that every propositional variable a appearing in the premise  of a one-step rule appears also in the conclusion: otherwise,\\\\nwe can eliminate a by passing from  to [/a]  [/a].\\\\nProposition 3.5. [Schr \\\\noder 2007] Every one-step sound rule is sound.\\\\nThe converse holds under additional assumptions [Schr oder 2005]; note however\\\\nthat the obviously sound rule / is one-step sound iff T  =  (as is the case e.g.\\\\nfor PML).\\\\nA given set R of one-step sound rules induces a proof system for F () as follows.\\\\nDefinition 3.6. Let RC denote the set of rules obtained by extending R with the\\\\ncongruence rule\\\\nab\\\\nLa  Lb\\\\nfor every L  . (This rule of course implies a rule where  is replaced by , which\\\\nhowever does not fit the format for one-step rules.) The set of provable formulas\\\\nis the smallest set closed under propositional entailment and the rules in RC , with\\\\npropositional variables instantiated to formulas in F (). We say that a formula \\\\nis consistent if  is not provable.\\\\n(C)\\\\n\\\\nIt is easy to see that this proof system is sound. Completeness requires enough\\\\nrules in the following sense.\\\\nDefinition 3.7. The set R is (strictly) one-step complete if, whenever T X,  |= \\\\nfor a set X,   Cl(Up(V )), and a P(X)-valuation  , then  is (strictly) provable\\\\nover X,  , i.e. propositionally entailed by clauses (a clause)  where /  RC\\\\n(Definition 3.6) and  is a Prop(V )-substitution (a V -substitution) such that X,  |=\\\\n.\\\\nStrict one-step completeness is one of crucial notions in this work. Its distinctive feature is that strict provability largely dispenses with propositional reasoning\\\\nby restricting instantiations to propositional variables, and by replacing general\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n9\\\\n\\\\npropositional entailment by the rather trivial concept of propositional entailment\\\\nbetween single clauses (cf. Lemma 3.2). This plays a central role in the shallow\\\\nmodel construction presented in Section 4.\\\\nRemark 3.8. It is shown in [Schr oder 2007] that the set of all one-step sound\\\\nrules is always strictly one-step complete and that the proof system induced by a\\\\none-step complete set of rules is weakly complete, i.e. proves all valid formulas.\\\\nIn the further treatment, we need a further technical condition.\\\\nDefinition 3.9. A one-step rule / over V is injective if every variable in V\\\\noccurs at most once in .\\\\nAssumption 3.10. We assume for the remainder of the paper that the given rules\\\\nin R are injective. This restriction will be satisfied by the naturally arising rule sets\\\\nin our examples; it can always be forced by introducing new propositional variables\\\\nand adding premises stating the equivalence to the original variables (e.g. a rule\\\\n/(a  a) can be replaced by (a  b)/(a  b)).\\\\nStrictly one-step complete sets of rules are generally more complicated than onestep complete sets of rules or axioms [Pattinson 2003; Schr oder 2007]. In our\\\\nterminology, part of the effort of [Vardi 1989] and [Pauly 2002] is devoted to finding\\\\nstrictly one-step complete sets of rules. We now develop a systematic procedure for\\\\nturning one-step complete rule sets into strictly one-step ",
    "Introduction": "complete ones. For the\\\\nfollowing, recall that given clauses  and  containing literals a and a, respectively,\\\\na resolvent of  and  (at a) is obtained by removing a and a from the clause\\\\n  . A set  of clauses is called resolution closed if, for ,   , all resolvents\\\\nof  and  are propositionally entailed by some clause in . This is generalised to\\\\nrules as follows:\\\\nDefinition 3.11. A set R of one-step rules is resolution closed if it satisfies the\\\\nfollowing requirement. Let R1 , R2  R, where R1 = 1 /1 and R2 = 2 /2 . We\\\\ncan assume that R1 and R2 have disjoint sets V1 , V2 of propositional variables. Let\\\\nLa be in 1 , and let Lb be in 2 for some L  , so that we have a resolvent\\\\n  of 1 and 2 [a/b] at La; by Assumption 3.10,   is a clause over Up(V ) where\\\\nV = V1  V2  {a, b}. Then RC is required to contain a rule R = / such\\\\n1  2 [a/b] PL  and  PL   for some V -substitution ; in this case, R is\\\\ncalled a resolvent of R1 and R2 .\\\\nResolution closure will play a central role in the following development, as it forms\\\\nthe syntactic counterpart of strict one-step completeness.\\\\nRemark 3.12. One can construct resolution closed sets by iterated addition of\\\\nmissing resolvents. Here, an obvious choice for a resolvent / of 1 /1 and 2 /2\\\\nas above is to take  as the resolvent   of 1 and 2 , and  as 1  2 [a/b], with a\\\\neliminated according to Remark 3.4 as a is not contained in  by Assumption 3.10.\\\\nIt is clear that 1  2 [a/b]/  is one-step sound if R1 and R2 are one-step sound.\\\\nRemark 3.13. Note that our approach is different to existing resolution-based\\\\napproaches to decision procedures for modal logic (e.g. [De Nivelle et al. 2000]),\\\\nwhich rely on translating modal logic into first-order logic.\\\\n\\\\n\\\\f10\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nLemma 3.14. Let   Cl(V ), and let  6=   Cl(V ) be resolution closed. Then\\\\n PL  iff  PL  for some   .\\\\nProof. The if direction is clear. Only if: W.l.o.g.  is not a tautology. We\\\\ncan assume that V is finite and then prove the contraposition of the claim by\\\\ninduction over the size of V . Thus assume, recalling Lemma 3.2, that  does not\\\\ncontain a subclause of . Pick a clause    that contains a minimal number of\\\\nliterals not in  (this number is non-zero); w.l.o.g.  contains a positive literal a\\\\nsuch that a is not in . Remove all clauses containing a from , and remove a\\\\nfrom the remaining clauses and from , obtaining a new set  of clauses and a\\\\nnew clause   , respectively. Then  is resolution closed and does not contain a\\\\nsubclause of   (otherwise there exists a clause    whose only literal not in \\\\nis a, and resolving  with  yields a clause in  with less literals not in  than ,\\\\ncontradiction). By induction we thus have a valuation   for V  {a} satisfying \\\\nbut not   . We extend   to a valuation  for V by putting  (a) = ; then \\\\nsatisfies  but not .\\\\nLemma 3.15. R is resolution closed iff RC is resolution closed.\\\\nProof. The if direction is trivial. The only if direction follows from the\\\\nfact that every rule R is a resolvent of R and any congruence rule, since rules are\\\\ninjective (Assumption 3.10).\\\\nTheorem 3.16. Let R be one-step complete. Then R is strictly one-step complete iff R is resolution closed.\\\\nProof. If : Let X be a set, let  be a P(X)-valuation, and let   Cl(Up(V ))\\\\nsuch that T X,  |= ; w.l.o.g.  is not a tautology. By one-step completeness,  is\\\\npropositionally entailed by the (non-empty) set of clauses\\\\n = { | /  RC ,  a Prop(V )-substitution, X,  |= }.\\\\nThe set  is resolution closed: for i = 1, 2, let i /i  RC be a rule over Wi\\\\n(with W1 , W2 disjoint), let i be a Prop(V )-substitution such that X,  |= i i ,\\\\nand let 1 1 and 2 2 contain literals L and L, respectively. Thus, 1 and 2\\\\ncontain literals La and Lb, respectively, where 1 (a) = 2 (b) = ; let   be the\\\\nresolvent of 1 , 2 [a/b] at La, a clause over W = W1  W2  {a, b}. Then the\\\\n  where  acts like 1 on W1  {a} and like 2 on\\\\nresolvent of 1 1 , 2 2 at L is ,\\\\nW2  {b}. By resolution closedness of RC (Lemma 3.15), we have /  RC and a\\\\n  Then X,  |= ,\\\\nW -substitution  such that 1  2 [a/b] PL  and  PL .\\\\n \\\\nso that   , and  PL  as required.\\\\nBy Lemma 3.14, it now follows that  PL  for some clause  in , where\\\\nby Lemma 3.2 necessarily (v)  V for every variable v in .\\\\nOnly if : Let 1 /2 , 2 /2  R be rules over disjoint sets V1 , V2 of variables,\\\\nwhere 1 contains La and 2 contains Lb. Let   denote the resolvent of 1 , 2 [a/b]\\\\nat La, a clause over V = V1  V2  {a, b}. Let X be the set of satisfying valuations\\\\nfor 1  2 [a/b], and define the P(X)-valuation  by  (a) = {  X | (a) = }.\\\\nThen X,  |= 1  2 [a/b] and hence T X,  |=   by one-step soundness of R. By\\\\nstrict one-step completeness, it follows that there exists a rule /  RC and a\\\\n  By construction of X,  , we\\\\nV -substitution  such that X,  |=  and  PL .\\\\nmay conclude from X,  |=  that 1  2 [a/b] PL  as required.\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n11\\\\n\\\\nIn summary, strictly one-step complete rule sets can be constructed by resolving\\\\nthe rules of a one-step complete axiomatisation against each other. Below, we give\\\\nexamples of strictly one-step complete systems obtained in this way. In order to\\\\nsimplify the presentation for the case of graded modal logic and probabilistic modal\\\\nlogic, we use the following notation. If i is a formula, ri  Z for all i  I, and\\\\nk  Z, we abbreviate\\\\n\\\\u0010^\\\\nX\\\\n^\\\\n_ \\\\u0011\\\\nj ,\\\\nri i  k \\\\nj \\\\niI\\\\n\\\\nJI\\\\nr(J)<k\\\\n\\\\njJ\\\\n\\\\nj J\\\\n/\\\\n\\\\nP\\\\nP\\\\nwhere r(J) = jJ rj . The formula iI ri ai  k translates into the arithmetic\\\\nof characteristic functions as suggested by the notation:\\\\nP\\\\nLemma 3.17. An element x  X belongs to the interpretation of iI ri ai  k\\\\nunder a P(X)-valuation  iff\\\\nX\\\\nri 1(ai ) (x)  k,\\\\niI\\\\n\\\\nwhere\\\\n\\\\n1A : X  {0, 1} is the characteristic function of A  X.\\\\n\\\\nProof. The element x P\\\\nsatisfies the negation of\\\\nJ = {i  I | x  (ai )} iff iI ri 1(ai ) (x) < k.\\\\n\\\\nP\\\\n\\\\niI\\\\n\\\\nri ai  k iff r(J) < k for\\\\n\\\\nP\\\\nP\\\\nWePallow ourselves\\\\nobvious variations of this notation, e.g.\\\\nai \\\\nbj in place\\\\nP\\\\nof\\\\nbj  ai  0.\\\\nIn all the logics of Example 2.7, the resolution process, applied to known one-step\\\\ncomplete rule sets, can be kept under control; by Theorem 3.16, the resulting rule\\\\nsets are strictly one-step complete.\\\\nExample 3.18. (1) Modal logic E: The empty set of rules is one-step complete\\\\nfor neighbourhood frame semantics (Example 2.7.3). This set is trivially resolution\\\\nclosed.\\\\n(2) Modal logic M : The one-step rule\\\\nab\\\\na  b\\\\nis one-step complete for monotone neighbourhood frame semantics (Example 2.7.3),\\\\nand clearly resolution closed.\\\\n(3) Modal logic K: The one-step rules\\\\n(M )\\\\n\\\\nabc\\\\na\\\\na\\\\na  b  c\\\\nare one-step complete for unrestricted Kripke semantics (Example 2.7.1), i.e. for\\\\nthe modal logic K [Pattinson 2003]. The resolution closure R of these rules consists\\\\nof the rules\\\\nVn\\\\na b\\\\nVn i=1 i\\\\ni=1 ai  b\\\\n\\\\nfor all n  N (here, strict one-step completeness is also easily seen directly). Note\\\\nthe similarity between this rule and a corresponding rule appearing in standard\\\\n\\\\n\\\\f12\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\ncut-free sequent calculi for K [Troelstra and Schwichtenberg 1996]; the precise\\\\nconnection between resolution closure and cut elimination is the subject of further\\\\ninvestigation.\\\\n(4) Modal logic KD: The axiomatisation of K is extended to a one-step complete\\\\naxiomatisation of KD (Example 2.7.2) by adding the rule a/a. Closing the\\\\nnew rule set under resolution leads to the rules\\\\nVn\\\\nVn\\\\nai  b\\\\n i=1 ai\\\\ni=1\\\\nVn\\\\nVn\\\\nand\\\\n i=1 ai\\\\ni=1 ai  b\\\\n\\\\nfor all n  N (i.e. where the rules of K apply only to positive Horn clauses, the\\\\nrules of KD apply to arbitrary Horn clauses).\\\\n\\\\n(5) Coalition logic: In Lemma 6.1 of [Pauly 2002], the following set of one-step\\\\nrules for coalition logic (Example 2.7.8), numbered as in loc. cit., is implicit:\\\\nWn\\\\nai\\\\na\\\\nab\\\\n(1) Wn i=1\\\\n(2)\\\\n(3)\\\\n[C]a\\\\n[0]a\\\\n [N ]b\\\\n[C\\\\n]a\\\\ni i\\\\ni=1\\\\nVn\\\\n\\\\nb\\\\ni=1 ai S\\\\n[C\\\\n]a\\\\n\\\\n[\\\\nCi ]b\\\\ni=1 i i\\\\n\\\\n(4) Vn\\\\n\\\\nwhere n  0, and rules (1) and (4) are subject to the side condition that the Ci are\\\\npairwise disjoint.\\\\nAs shown in [Pauly 2002], an axiomatization subsumed by rules (1)(4) is complete\\\\nfor a language including propositional symbols; one-step completeness follows by\\\\nProposition 5.3 below. The rules are moreover nearly resolution closed (full resolution closure is not needed in [Pauly 2002] due to the use of a taylored notion\\\\nof closed rule set). Resolving rule (4) with rules (2) and (3), one obtains the rule\\\\nschema\\\\nWm\\\\nVn\\\\nj=1 cj\\\\ni=1 ai  b \\\\n\\\\nV\\\\nW\\\\n(4 )\\\\nn\\\\nm\\\\ni=1 [Ci ]ai  [D]b \\\\nj=1 [N ]cj\\\\n\\\\nwhere m, n  0, subject to the side condition that the Ci are pairwise disjoint\\\\nsubsets of D; this subsumes rules (2)(4) above.\\\\nResolution closedness of rules (1) and (4): We discuss only the case of resolving\\\\n(4 ) against itself; the other case is similar. Let one instance of (4 ) be denoted as\\\\nin the rule schema, and another instance with all entities primed (ai etc.). The\\\\ntwo instances can be resolved in two essentially different ways. The subcase where\\\\nmatching is with [D]b is straightforward. Thus assume w.l.o.g. that matching is via\\\\n[N ]c1  [C1 ]a1 . Then by the side conditions, D = N and Ci =  for i = 2, . . . , n .\\\\nThus, the resolvent has the conclusion\\\\nWm\\\\nWm\\\\nVn\\\\nVn\\\\n\\\\n \\\\n\\\\nj=1 [N ]cj ,\\\\ni=2 [Ci ]ai  [D]b  [N ]b \\\\nj=2 [N ]cj \\\\ni=1 [Ci ]ai \\\\nwhich fits the format of the rule scheme (4 ). It is easy to check that the combined\\\\npremises imply the required premise for the resolved conclusion, and similarly for\\\\nthe side conditions.\\\\n\\\\n(6) Graded modal logic: The standard axiomatization of graded modal logic,\\\\n\\\\n\\\\f\\\\n\\\\nPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n13\\\\n\\\\nweakly complete for a language with propositional symbols [Caro 1988], has axioms\\\\n(G1)\\\\n\\\\nn+1 a  n a\\\\n\\\\n(G2)\\\\n\\\\n\\\\u00030 (a  b)  n a  n b\\\\n\\\\n(G3)\\\\n\\\\n!0 (a  b)  ((!n1 a  !n2 b)  !n1 +n2 (a  b))\\\\n\\\\n(N )\\\\n\\\\n\\\\u00030 \\\\n\\\\nwhere n, n1 , n2  N, used in a proof system including propositional reasoning and\\\\nthe congruence rule (so that (N ) induces the necessition rule for \\\\u00030 ). Here, !n \\\\nabbreviates n1   n  for n > 0, and 0  for n = 0. These axioms may be\\\\nderived from the system of one-step rules\\\\nab\\\\ncab\\\\n(A1)\\\\nn+1 a  n b\\\\nn1 +n2 c  n1 a  n2 b\\\\nabc\\\\nabd\\\\na\\\\n(RN )\\\\n(A2)\\\\nn1 a  n2 b  n1 +n2 +1 c  0 d\\\\n0 a\\\\n\\\\n(RG1)\\\\n\\\\n((G1) and (N ) are easily derived from (RG1) and (RN ), respectively; (G2) follows\\\\nby (A1) taking n2 = 0; and (G3) may be derived using (A1) and (A2)). All these\\\\nrules are subsumed by the rule schema\\\\nPm\\\\nPn\\\\nj=1 bj\\\\ni=1 ai \\\\nWm\\\\n(G) Vn\\\\n,\\\\nj=1 lj bj\\\\ni=1 ki ai \\\\n\\\\nP\\\\nP\\\\nwhere n, m  0, subject to the side condition ni=1 (ki + 1)  1 + m\\\\nj=1 lj (which\\\\nentails that n and m cannot both be 0). One-step soundness of (G) follows from onestep soundness of the rule system for majority logic proved in the next example. By\\\\nthe preceding considerations, (G) is weakly complete, and hence one-step complete\\\\nby Proposition 5.3.\\\\nResolution closedness of (G): Take two instances of (G), one denoted like in the\\\\ngeneral form of the rule and one with all entities primed (ai etc.), with the resolution\\\\ntaking place w.l.o.g. by matching k1 a1  l1 b1 . The conclusion of the arising\\\\nresolvent is\\\\nn\\\\n^\\\\n\\\\n\\\\n\\\\nki ai \\\\n\\\\nm\\\\n^\\\\n\\\\nki ai\\\\n\\\\n\\\\n\\\\nSince a1  b1 , the premises\\\\n\\\\nPn\\\\n\\\\nn\\\\nX\\\\ni=1\\\\n\\\\ni=1\\\\n\\\\nai +\\\\n\\\\n\\\\n\\\\n lj b j \\\\n\\\\nai \\\\n\\\\n\\\\nn\\\\nX\\\\n\\\\nPm\\\\n\\\\nj=1 bj\\\\n\\\\nai\\\\n\\\\n\\\\n\\\\nand\\\\n\\\\nPn\\\\n\\\\nlj bj .\\\\n\\\\nPn\\\\n\\\\ni=1\\\\n\\\\nai \\\\n\\\\n\\\\n\\\\nbj +\\\\n\\\\nj=2\\\\n\\\\ni=2\\\\n\\\\nand since k1 = l1 , the side conditions\\\\n\\\\nm\\\\nX\\\\n\\\\nm\\\\n_\\\\n\\\\nj=1\\\\n\\\\ni=2\\\\n\\\\ni=2\\\\n\\\\ni=1\\\\n\\\\nm\\\\n_\\\\n\\\\ni=1 (ki +1)\\\\n\\\\nm\\\\nX\\\\n\\\\nP m\\\\n\\\\n\\\\nj=1 bj\\\\n\\\\nimply\\\\n\\\\nbj ,\\\\n\\\\nj=1\\\\n\\\\n 1+\\\\n\\\\nPm\\\\n\\\\nj=1 lj\\\\n\\\\nand\\\\n\\\\nPn\\\\n\\\\n\\\\ni=1 (ki +1)\\\\n\\\\n\\\\n\\\\n\\\\f14\\\\n\\\\n1+\\\\n\\\\n\\\\nP m\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\n\\\\ni=1 lj\\\\n\\\\nimply\\\\nn\\\\nX\\\\ni=1\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nm\\\\nm\\\\nn\\\\nX\\\\nX\\\\nX\\\\n\\\\nlj ,\\\\nlj +\\\\n(ki + 1)  1 +\\\\n(ki + 1) +\\\\nj=2\\\\n\\\\ni=2\\\\n\\\\nj=1\\\\n\\\\nso that we arrive again at an instance of (G).\\\\n(7) Majority logic: in [Pacuit and Salame 2004], the extension of the axiomatization of graded modal logic with the axioms\\\\n(M 1)\\\\n\\\\nM a  M b  0 (a  b)\\\\n\\\\n(M 2)\\\\n\\\\nM a  \\\\u00030 (a  b)  M b\\\\n\\\\n(M 3)\\\\n\\\\nW a  W b  n (a  b)  n (a  b)\\\\n\\\\n(M 4)\\\\n\\\\nW a  M b  n (a  b)  n+1 (a  b)\\\\n\\\\nis proved to be weakly complete for majority logic including propositional symbols.\\\\nThese axioms are derivable from the set of rules\\\\n(RM 1)\\\\n\\\\nab\\\\nWa  Wb\\\\n\\\\n(a  c)\\\\n(b  c)\\\\nab d\\\\n(RM 3)\\\\nW a  W b  n c  n d\\\\n\\\\n(RM 2)\\\\n\\\\nabc\\\\nW a  W b  0 c\\\\n\\\\na  b\\\\nacd\\\\nbc\\\\n(RM 4)\\\\nW a  n b  W c  n+1 d\\\\n\\\\n((M 2), (M 3) and (M 4) follow directly from (RM 2), (RM 3) and (RM 4), respectively; (RM 1) proves M a  W a, whence (M 1) is obtained from (RM 2)). These\\\\nrules and rule (G) for GML are subsumed by the rule schema\\\\nPw\\\\nPm\\\\nPv\\\\nPn\\\\nds\\\\nj=1 bj +\\\\nr=1 cr + u \\\\ni=1 ai +\\\\nWs=1\\\\nVv\\\\nWm\\\\n(u  Z)\\\\n(Mu ) Vn\\\\nw\\\\nb\\\\n\\\\na\\\\n\\\\nW\\\\nc\\\\n\\\\n\\\\n\\\\nr\\\\ns=1 W ds\\\\nr=1\\\\nj=1 lj j\\\\ni=1 ki i\\\\nPn\\\\nPm\\\\nwith side conditions i=1 (ki +1) j=1 lj 1+wmax(u, 0)  0 and vw+2u  0\\\\n(take u = 1 for (RM 1), u = 0 for (RM 2), (RM 4), and (G), and u = 1 for\\\\n(RM 3)). Resolution closedness is checked analogously as for graded modal logic,\\\\ncovering the two cases of resolution at literals n a and W a, respectively; in both\\\\ncases, an instance of Mu1 +u2 can be taken as a resolvent of an instance of Mu1 and\\\\nan instance of Mu2 .\\\\nOne-step\\\\nsoundness\\\\nof (M\\\\n be a P(X)-valuation such that X,  |=\\\\nPn\\\\nPv\\\\nPum): Let P\\\\nw\\\\ni=1 ai +\\\\nr=1 cr + u \\\\nj=1 bj +\\\\ns=1 ds . Let B  B(X). Using Lemma 3.17,\\\\nwe obtain by summation over x  X\\\\nn\\\\nX\\\\ni=1\\\\n\\\\nB((ai )) +\\\\n\\\\nv\\\\nX\\\\nr=1\\\\n\\\\nB((cr )) + uB(X) \\\\n\\\\nm\\\\nX\\\\nj=1\\\\n\\\\nB((bj )) +\\\\n\\\\nw\\\\nX\\\\n\\\\nB((ds )).\\\\n\\\\ns=1\\\\n\\\\nNow put p = B(X)/2 (with x = min{z  Z | z  x}) so that B satisfies W a iff\\\\nB( (a))  p. To establish that B is in the interpretation of the conclusion of Mu ,\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n15\\\\n\\\\nit suffices to prove\\\\nn\\\\nX\\\\n\\\\n(ki + 1) + vp + uB(X) \\\\n\\\\nm\\\\nX\\\\n\\\\nlj + w(p  1) + 1.\\\\n\\\\nj=1\\\\n\\\\ni=1\\\\n\\\\nBy the side conditions, this inequality is equivalent to\\\\n2up + uB(X) + max(u, 0)  0,\\\\nwhich is easily established by distinguishing the cases B(X) = 2p and B(X) =\\\\n2p  1.\\\\n(8) Probabilistic modal logic: By reformulating the one-step complete set of axioms for probabilistic modal logic given by Crstea and Pattinson [2007] as one-step\\\\nrules and subsequently applying resolution, one obtains the rules\\\\nPm\\\\nPn\\\\nbj\\\\ni=1 ai + u \\\\nWm j=1\\\\n(Pu ) Vn\\\\n,\\\\nj=1 Lqj bj\\\\ni=1 Lpi ai \\\\nwhere m, n  0, m + n  1, and u  Z, subject to the side condition\\\\nPn\\\\nPm\\\\ni=1 pi + u \\\\nj=1 qj and\\\\nPn\\\\nif m = 0.\\\\ni=1 pi + u > 0\\\\n\\\\nOne-step completeness of (Pu ): The rule schema is one-step complete, as it subsumes the following axiomatisation that has been shown to be one-step complete\\\\nin loc.cit.:\\\\na  b\\\\na\\\\n(> 1)\\\\n(p + q > 1)\\\\n(0) L0 a ()\\\\nLp a\\\\nLp a  Lq b\\\\n(1)\\\\n(1)\\\\n\\\\nab\\\\n(p + q = 1)\\\\nLp a  Lq b\\\\nPr\\\\n\\\\nPs  \\\\ni=1 ci =\\\\nj=1 dj\\\\nVs\\\\nVr\\\\nj=2 L(1vj ) dj\\\\ni=1 Lui ci \\\\n\\\\n Lv1 d1\\\\n\\\\n,\\\\n\\\\nwhere d 1 = d1 and d j = dj for j  2, and rule (1) is subject to the side condition\\\\ns\\\\nX\\\\nj=1\\\\n\\\\nvj =\\\\n\\\\nr\\\\nX\\\\n\\\\nui .\\\\n\\\\ni=1\\\\n\\\\nThese rules are subsumed by the rule schema (Pu ), as follows. Rule (0): take\\\\nm = 1, n = 0, u = 0, q1 = 0. Rule (): take m = 1, n = 0, u = 1. Rule > 1:\\\\ntake n = 2, m = 0, u = 1. Rule (1): take n = 0, m = 2, u = 1. Rule (1): take\\\\nm = 1, n = r + s  1, u = 1  s, and instantiate bi to ci for i = 1, . . . , r, bi to dir+1\\\\nfor i = r + 1, . . . , r + s  1, a1 to d1 , qi to ui for i = 1, . . . , r, qi to 1  vir+1 for\\\\ni = r + 1, . . . , r + s  1, and p1 to v1 .\\\\nOne-step soundness: Analogously to the previous example, using additionally that\\\\none always has P (X) = 1.\\\\nResolution closedness: Analogously as for graded modal logic; as a resolvent of an\\\\ninstance of Pu1 and an instance of Pu2 , one can take an instance of Pu1 +u2 .\\\\n\\\\n\\\\f16\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\n4. THE SHALLOW MODEL CONSTRUCTION\\\\nWe now present the announced generic shallow model construction, which is based\\\\non strictly one-step complete axiomatisations. The construction generalises results\\\\nfrom [Vardi 1989] (where the use of axiomatisations is implicit in certain lemmas).\\\\nDefinition 4.1. The set MA() of (top level) modal atoms of a formula  is\\\\ndefined recursively by MA(  ) = MA()  MA(), MA() = MA(), and\\\\nMA(L) = {L}. (Note that   Prop(MA()).) A pseudovaluation is a conjunctive clause H over Up(F ()), represented as a set of literals (i.e. pseudovaluations\\\\nare identified modulo contraction and reordering of literals, which does not affect the\\\\nset MA(H) of modal atoms). A pseudovaluation is consistent if it is consistent as an\\\\nF ()-formula. We say that H is a pseudovaluation for  if MA(H)  MA() and\\\\nH PL . If / is a rule in RC and  is a substitution such that   Cl(MA(H))\\\\nand H PL , then the negated instance  of the premise  is a demand of H.\\\\nThis generalises the notion of demand [Blackburn et al. 2001, Definition 6.43] to\\\\na coalgebraic setting. Note that by the dual of Lemma 3.2, all demands of a\\\\npseudovaluation H are contained in H when regarded as sets of literals, unless H is\\\\npropositionally inconstent (i.e. contains both L and L for some modal atom L).\\\\nLemma 4.2. Every consistent formula has a consistent pseudovaluation.\\\\nProof. If  is consistent, then one of the conjunctive clauses from its disjunctive\\\\nnormal form (DNF) is consistent and hence is a consistent pseudovaluation for .\\\\nLemma 4.3. Every demand of a consistent pseudovaluation is consistent.\\\\nProof. By contraposition: Let H be a pseudovaluation, and let / be a rule\\\\nin RC such that   Cl(MA(H)) and H PL . If the demand  is inconsistent, then  is provable; hence,  is provable using /, and consequently H\\\\nis inconsistent.\\\\nDefinition 4.4. A supporting Kripke frame of a T -coalgebra (X, ) is a Kripke\\\\nframe (X, K) (consisting of a set X and a transition relation K  X  X) such that\\\\nfor each x  X,\\\\n(x)  T {y | xKy}  T X.\\\\nLemma and Definition 4.5. If a coalgebra C = (X, ) is equipped with a supporting Kripke frame (X, K), then for every state x  X, the set Xx of states\\\\nreachable from x in (X, K) is the carrier of a subcoalgebra Cx = (Xx , x ) of C, the\\\\nsubmodel generated by x.\\\\nNote that by Proposition 2.5, y |=Cx  iff y |=C  for y  Xx .\\\\nDefinition 4.6. A shallow tableau is a Kripke frame (X, K) with a distinguished\\\\nroot H0  X such that X is a set of pseudovaluations, every state is reachable\\\\nfrom H0 , for all H, G  X,\\\\nHKG = G is a pseudovaluation for a demand of H,\\\\nand for every demand  of H  X there exists a pseudovaluation G  X for  such\\\\nthat HKG. Given a formula , a shallow tableau for  is a shallow tableau whose\\\\nroot is a pseudovaluation for .\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n17\\\\n\\\\nA shallow tableau model is a T -coalgebra C = (X, ) which has a supporting\\\\nKripke frame (X, K) such that (X, K) is a shallow tableau and the truth lemma\\\\nH PL  = H |=C \\\\n\\\\nfor all F ()-formulas \\\\n\\\\nholds for all H  X (hence in particular H |=C  if H is a pseudovaluation for ).\\\\nA shallow tableau is almost a dag, except that in the presence of the rule / (cf.\\\\nSection 3) the pseudovaluation  is a pseudovaluation for one of its own demands.\\\\nExplicitly:\\\\nProposition 4.7. A shallow tableau (X, K) with root H0 is, up to a possible\\\\nloop at the state , a dag of depth at most the depth of H0 , and the branching\\\\ndegree at H  X is exponentially bounded in |H|.\\\\nProof. The first claim follows from the fact the the depth of all demands of\\\\na pseudovaluation H is strictly less than the depth of H. To prove the bound on\\\\nbranching, note that pseudovaluations for demands of H are conjunctive clauses\\\\nover the set of subformulas of H.\\\\nLemma 4.8. If a formula  has a pseudovaluation H0 such that all demands of\\\\nH0 are consistent, then there exists a shallow tableau for .\\\\n(By Lemmas 4.2 and 4.3, the conditions of the above lemma hold in particular if \\\\nis satisfiable.)\\\\nProof. Let Z consist of H0 and all consistent pseudovaluations, and for H, G \\\\n  iff G is a pseudovaluation for a demand of H. Let (X, K) be the\\\\nZ put H KG\\\\n  generated by H0 (i.e. X is the set of states reachable from H0 in\\\\nsubframe of (Z, K)\\\\n \\\\n   (X  X)). By the assumption on H0 and Lemmas 4.2 and 4.3,\\\\n(Z, K), and K = K\\\\n(X, K) is a shallow tableau for .\\\\nTheorem 4.9. If R is strictly one-step complete, then every shallow tableau is\\\\na supporting Kripke frame of a shallow tableau model.\\\\nProof. Let (X, K) be a shallow tableau; we have to construct a shallow tableau\\\\nmodel C = (X, ) for which (X, K) is a supporting Kripke frame. To begin, note\\\\nthat to ensure the truth lemma, it suffices that C is coherent in the sense that for\\\\nH  X and Y = {G | HKG},\\\\nH PL L  (H)  [[L]]Y {G  Y | G |=CG } for all L  MA(H)\\\\n(cf. Lemma and Definition 4.5) : note that {G  Y | G |=CG } = [[]]C  Y , so that\\\\nby naturality of predicate liftings, coherence implies that\\\\nH PL L  H |=C L for all L  MA(H).\\\\nThe extension to propositional consequences of H is then straightforward (noting\\\\nthat for L  MA(H), either H PL L or H PL L).\\\\nWe construct a coherent coalgebra structure  by induction over the depth of\\\\npseudovaluations. Thus, let H  X, put Y = {G | HKG}, and assume that  is\\\\nalready constructed for all pseudovaluations of smaller depth in X, in particular for\\\\nall states G reachable from H in (X, K). Thus, the submodel CG generated by such\\\\n\\\\n\\\\f\\\\n\\\\n18\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\na state G is already defined, and coherence at G is unaffected by the construction\\\\nof (H).\\\\nWe have to prove that there exists (H)  T Y  T X satisfying the coherence\\\\ncondition. Assume the contrary. Let V be the set of propositional variables b ,\\\\nwhere L  MA(H) for some L. Let   Cl(Up(V )) consist of the literals Lb\\\\nfor L  H and Lb for L  H. By assumption, T Y,  Y |= , where  Y is the\\\\nP(Y )-valuation taking b to {G  Y | G |=CG }. By strict one-step completeness,\\\\nit follows that  PL  for a rule / in RC and a V -substitution  such that\\\\nY,  Y |= . By construction of , H PL  and hence H PL . Thus,\\\\n is a demand for H, and hence there exists in Y a pseudovaluation G for .\\\\nBy the truth lemma for G, G |=CG , in contradiction to Y,  Y |= .\\\\nCorollary 4.10. If R is strictly one-step complete, then the following are\\\\nequivalent for an F ()-formula .\\\\n(1 )\\\\n(2 )\\\\n(3 )\\\\n(4 )\\\\n(5 )\\\\n(6 )\\\\n\\\\n is satisfiable.\\\\n is consistent.\\\\n has a pseudovaluation H such that all demands of H are consistent.\\\\n has a pseudovaluation H such that all demands of H are satisfiable.\\\\nThere exists a shallow tableau for .\\\\n is satisfiable at the root of a shallow tableau model.\\\\n\\\\nProof. (1) = (2): By soundness.\\\\n(2) = (3): By Lemmas 4.2 and 4.3\\\\n(3) = (5): By Lemma 4.8.\\\\n(5) = (6): By Theorem 4.9.\\\\n(6) = (1): Trivial.\\\\n(3)  (4): By the equivalence (1)  (2) already established.\\\\nThe above implies in particular that the proof system is weakly complete, i.e. proves\\\\nall valid formulas; this reproves a result of [Pattinson 2003]. By Remark 3.8, we\\\\nobtain moreover that coalgebraic modal logic has the shallow model property:\\\\nCorollary 4.11 Shallow model property. Every\\\\nsatisfiable\\\\nF ()formula  is satisfiable in a shallow model, i.e. in a T -coalgebra that has a\\\\nsupporting Kripke frame (X, K) which has final state x , i.e. x Kx implies\\\\nx = x , and which, up to a possible loop at x , is a dag of depth at most the depth\\\\nof  and of size at most 3n , where n is the number of subformulas of .\\\\nProof. All that remains to be checked is the bound on the size: every state in\\\\na shallow tableau is a set representing a conjunctive clause over subformulas of ,\\\\nin which a given subformula may occur as a positive literal, as a negative literal, or\\\\nnot at all.\\\\n5. SHALLOW PROOFS\\\\nThe satisfiability criterion of Corollary 4.10 can be rephrased in terms of a shallow proof property. This property can be proved semantically by dualising Corollary 4.10, as done in the proof of Corollary 5.1 below. Alternatively, the shallow\\\\nproof property can be established purely syntactically, without any reference to\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n19\\\\n\\\\nmodels; we present such an argument in the proof of Theorem 5.2 below. The shallow model construction presented in the previous section is however of independent\\\\ninterest.\\\\nCorollary 5.1 Shallow Proof Property. Let R be strictly one-step complete. Then an F ()-formula  is provable iff for each clause  in the conjunctive\\\\nnormal form (CNF) of , there exists a rule /  RC and a substitution  such\\\\nthat  PL  and  is provable.\\\\nProof. The if direction is trivial; we prove only if. Dualizing the implication\\\\n(3) = (2) in Corollary 4.10 yields\\\\nif  is provable then each pseudovaluation H for  has a demand \\\\nsuch that  is provable.\\\\nNow let  be a clause in the CNF of . Then  is a conjunctive clause in the DNF\\\\nof , in particular a pseudovaluation for . By the above condition, there exists\\\\na rule /  RC and a substitution  such that  PL , hence  PL ,\\\\nand  is provable.\\\\nIn a purely syntactic formulation of the shallow proof property, we have to replace\\\\nstrict completeness by closedness under resolution. The statement thus takes the\\\\nfollowing form.\\\\nTheorem 5.2 Shallow Proof Property. Let R be resolution closed. Then\\\\nan F ()-formula  is provable under R iff for each clause  in the CNF of , there\\\\nexists a rule /  RC and a substitution  such that  PL  and  is provable.\\\\n(This reproves Corollary 5.1, as strict one-step completeness implies resolution\\\\nclosedness by Theorem 3.16.)\\\\nProof. Again, if is trivial, and we prove only if. Let  be provable, and\\\\nlet  be a clause in the CNF of . Then  is provable. By definition of the proof\\\\nsystem,  is propositionally entailed by the set of clauses\\\\n = { | /  RC ,  provable}.\\\\nOne shows analogously as in the if direction of the proof of Theorem 3.16 that \\\\nis resolution closed. By Lemma 3.14, there exists  in  such that  PL .\\\\nWe hope that both proofs of the shallow proof property provide a handle for generalizations to logics outside rank 1.\\\\nOne application of the shallow proof property is\\\\nProposition 5.3. Let  contain an infinite set U of propositional symbols, modelled as in Remark 2.8 over a functor TU of the form TU X = T X  P(U ). Then\\\\nthe proof system induced by R is weakly complete iff R is one-step complete.\\\\nProof. W.l.o.g. R is resolution closed (one can close under resolution, thereby\\\\naffecting neither completeness nor one-step completeness). The if direction is\\\\nknown (cf. Remark 3.8). To prove the only if directio",
    "Related Work": "n, let   Cl(Up(V )), let X\\\\nbe a set, and let  be a P(X)-valuation such that TU X,  |= . Since U is infinite\\\\nand V may be assumed to be finite, we can assume w.l.o.g. that V  U . Let  denote\\\\n\\\\n\\\\f20\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nthe propositional theory of  , i.e. the conjunction of all contracted clauses  over V\\\\nsuch that X,  |= . Then one checks as in the proof of Theorem 17 in [Schr oder\\\\n2007] that the rule / is one-step sound. By Lemma 16 in [Schr oder 2007], there\\\\nexists a Prop(V )-substitution  such that  and   (a  (a)) (for each a  V )\\\\nare propositional tautologies. Since V  U , we can regard  as an F ()-formula.\\\\nAs such,  is valid. By soundness of /, it follows that , again regarded as an\\\\nF ()-formula, is valid, hence provable by weak completeness. By the shallow proof\\\\nproperty (Theorem 5.2), there exist a rule / over W and a Prop(V )-substitution \\\\nsuch that  is provable and  PL . By Lemma 3.2 and Assumption 3.10, it\\\\nfollows that there exists a V -substitution  such that ((b)) = (b) for all b  W\\\\nand  PL .\\\\nIt remains to prove that X,  |= . From X,  |=  and the construction of ,\\\\nwe obtain X,  |= a  (a) for all a  V and hence X,  |= (b)  (b) for all\\\\nb  W , so that the goal follows from X,  |= .\\\\nRemark 5.4. In the above result, the assumption that  contains enough propositional symbols is essential. E.g. in cases like coalition logic or probabilistic modal\\\\nlogic where the logic collapses into triviality without propositional symbols, the\\\\nempty set of rules is complete, but not one-step complete.\\\\nThe proof-theoretic content of Theorem 5.2 goes beyond the mere fact that proofs\\\\nare shallow. The theorem asserts that if the rule system is resolution closed, then\\\\npropositional reasoning can always be limited to decomposing a formula into the\\\\nclauses of its CNF and propositional entailment (i.e. by Lemma 3.2 essentially\\\\ncontainment) between clauses. Moreover, shallow proofs witness a weak subformula\\\\nproperty: every provable formula has a proof that mentions only propositional\\\\ncombinations of subformulas. Formally:\\\\nTheorem 5.5 Weak subformula property. Suppose that R is resolution\\\\nclosed and  is derivable under R. Then there exists a proof of  that mentions\\\\nonly propositional combinations of subformulas of .\\\\nProof. Assume that  is derivable under R and  is a clause of the CNF of ;\\\\nw.l.o.g.  is not a tautology. By Theorem 5.2 we find a rule /  R and a\\\\nsubstitution  such that  PL  and  is provable under R; by Lemma 3.2, \\\\ncontains , hence we can assume w.l.o.g. that  maps propositional variables to\\\\nsubformulas of . As  is a purely propositional formula, the substituted premise\\\\n is a propositional combinations of subformulas of , hence also of . The claim\\\\nnow follows inductively.\\\\nAs a consequence, it is immediate that F () is a conservative extension of any\\\\nsublanguage F (0 ) induced by a sub-signature 0  :\\\\nCorollary 5.6 Conservativity. Suppose R is resolution closed, 0   is a\\\\nsub-signature and R0 consists of those /  R that mention only modal operators\\\\nin 0 . Then a formula   F (0 ) is R-derivable iff it is R0 -derivable.\\\\nIn particular, if R is weakly complete for F (), then R0 is weakly complete\\\\nfor F (0 ).\\\\nExample 5.7. From completeness of the rules (Mu ) for majority logic (Exam-\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n21\\\\n\\\\nple 3.18.7), we obtain that the rules\\\\nPv\\\\nPw\\\\ncr + u  s=1 ds\\\\nr=1\\\\nWw\\\\n(u  Z)\\\\n(Wu ) Vv\\\\nr=1 W cr \\\\ns=1 W ds\\\\n\\\\nwith side conditions w  1  max(u, 0)  0 and v  w + 2u  0 form a complete\\\\naxiomatisation of the majority operator W alone. (Pauly [2005] considers a similar\\\\nlanguage, but without nesting of modal operators in formulas.)\\\\n6. A GENERIC PSPACE ALGORITHM\\\\nWe will now exploit the shallow model result (Corollary 4.10) to design a decision\\\\nprocedure for satisfiability in the spirit of [Vardi 1989]. This requires one more\\\\npreparatory step: since resolution closed rule sets are in general infinite, we must\\\\nensure that we never need to instantiate a rule in such a way that the conclusion\\\\ncontains the same literal twice; otherwise, determining the demands of a given\\\\npseudovaluation (Definition 4.1) might require checking infinitely many rules. This\\\\nis formally captured as follows.\\\\n\\\\nDefinition 6.1. An instance / of a rule / is contracted if the clause  is\\\\ncontracted (Definition 3.1). In this case, if H is a pseudovaluation (Definition 4.1)\\\\nsuch that   Cl(MA(H)) and H PL , the demand  of H is called an\\\\nessential demand. We say that a set R of rules is closed under contraction if for\\\\nevery V -instance / of a rule / over V in R, there exists a contracted V instance    /    of a rule  /   R such that     propositionally entails \\\\nand  propositionally entails    .\\\\nI.e. a rule set is closed under contraction if every instance of a rule that duplicates\\\\nliterals in the conclusion can be replaced by a contracted instance of a different rule.\\\\nNot all the rule sets discussed in Example 3.18 satisfy this property, but they can\\\\neasily be closed under contraction: just add a rule  /  for every rule / over V\\\\nin R and every V -substitution , where  is some suitably chosen propositional\\\\nequivalent of  and   is obtained from  by removing duplicate literals. It is\\\\nclear that the new rules remain one-step sound. Note that extending the rule set\\\\ntrivially preserves strict one-step completeness, so that there is no need to close the\\\\nextended rule set under resolution again.\\\\nFor convenience, we introduce further notation for propositional formulas: if\\\\nr  Z  {0} and  is a formula, then we put\\\\n(\\\\n\\\\nr>0\\\\nsgn(r) =\\\\n r < 0.\\\\nExample 6.2. (1) The strictly one-step complete rule sets of Examples 3.18.1\\\\n5 (E, M , K, KD, and coalition logic) are easily seen to be closed under contraction,\\\\nessentially because in all relevant rule schemas, the premise is a clause of the same\\\\ngeneral format as the conclusion.\\\\n(2) Graded modal logic: The rule schema (G) of Example 3.18.6 fails to be closed\\\\nunder contraction, as duplicating literals in the conclusion substantially affects both\\\\nthe premise and the side condition. We can close (G) under contraction as described\\\\n\\\\n\\\\f22\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nabove; this results in the rule schema\\\\nPn\\\\nri ai  0\\\\n(G ) Wn i=1\\\\n,\\\\nsgn(r\\\\ni )ki ai\\\\ni=1\\\\n\\\\nP\\\\nwhere n \\\\nP1 and r1 , . . . , rn  Z  {0}, subject to the side condition ri <0 ri (ki +\\\\n1)  1 + ri >0 ri ki .\\\\n(3) Majority logic: Similarly, closing the rule schema (Mm ) for majority logic\\\\nunder contraction yields the rule schema\\\\nPn\\\\nPv\\\\nm  i=1 ri ai + j=1 sj bj\\\\n\\\\nW\\\\n(ri , sj  Z  {0}, m  Z)\\\\n(Mm ) W\\\\nsgn(ri )ki ai  sgn(sj )W bj\\\\nP\\\\nP\\\\nP\\\\nwith side conditions ri <0 ri (ki + 1)  ( ri >0 ri ki )  1 + sj >0 sj  max(m, 0)  0\\\\nP\\\\nand 2m  sj  0.\\\\n(4) Probabilistic modal logic: The rule schema (Pk ) of Example 3.18.8 fails to\\\\nbe closed under contraction. Closure under contraction as described above leads to\\\\nthe rule schema\\\\nPn\\\\n\\\\ni=1 ri ai  k\\\\n(Pk ) W\\\\n1in sgn(ri )Lpi ai\\\\nwhere n  1 and r1 , . . . , rn  Z  {0}, subject to the side condition\\\\nPn\\\\nri pi  k, and\\\\nPni=1\\\\nif i. ri < 0 then i=1 ri pi < k.\\\\nThe crucial property of contraction closed rule sets is\\\\n\\\\nLemma 6.3. If R is closed under contraction, then all the demands of a pseudovaluation are satisfiable iff all its essential demands are satisfiable.\\\\nProof. The only if direction is trivial. We prove if: Let R be closed under contraction. Then also RC is closed under contraction, since instances of the\\\\ncongruence rule never contain duplicate literals. Thus, every demand of a pseudovaluation H is propositionally entailed by an essential demand.\\\\nThus we can extend Corollary 4.10 as follows.\\\\nCorollary 6.4. If R is strictly one-step complete and closed under contraction,\\\\nthen an F ()-formula  is satisfiable iff  has a pseudovaluation H such that all\\\\nessential demands of H are satisfiable.\\\\nIn the algorithm suggested by Corollary 6.4, we will encode demands, which are\\\\nthemselves too large to be passed around directly, by the rules that induce them.\\\\nHere, we need to represent rules by suitable codes, i.e. strings over some alphabet,\\\\nsince a naive direct representation of rules would in particular have to deal with\\\\nrule premises of potentially exponential size.\\\\nWn\\\\nDefinition 6.5. We say that a ruleWR  R matches a clause   i=1 oi Li i\\\\nif the conclusion of R is of the form ni=1 oi Li ai . In this case, let (R, ) denote\\\\nthe arising substitution [i /ai ]i=1,...,n . Two rules matching the same clause are\\\\nequivalent if their premises are propositionally equivalent; equivalence classes [R]\\\\nare called R-matchings. The code of R is also a code for [R].\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n23\\\\n\\\\nWe fix some size measures for the representation of formulas and rules:\\\\nDefinition 6.6. The size size(a) of an integer a is log2 (|a| + 1), where r =\\\\nmin{z  Z | z  r} as usual. The size size(p) of a rational number p = a/b, with\\\\na, b relatively prime, is 1 + size(a) + size(b). The size || of a formula  over V is\\\\ndefined by counting 1 for each propositional variable, boolean operator, or modal\\\\noperator, and additionally the size of each index of a modal operator. (In the\\\\nexamples, indices are either numbers, with sizes as above, or subsets of {1, . . . , n},\\\\nassumed to be of size n.)\\\\nAssumption 6.7. We assume a reasonable encoding of modal formulas in which\\\\nboolean operators take up constant space and modal operators take up space according to a given coding of ; we assume that this coding is in NP (i.e. it is\\\\ndecidable in NP whether a given code is a valid code for a modal operator in ).\\\\nGraded or probabilistic modal operators are assumed to be coded in binary, with\\\\nsizes according to Definition 6.6.\\\\nExample 6.8. For the rules of Examples 3.18 and 6.2, we just take the parameters\\\\nof a rule as its code in the obvious way. E.g. the code of an instance of (Pk )\\\\nas displayed in Example 6.2.4 consists of n, k, the ri , and the pi . The size of\\\\nthe\\\\nP code is determined\\\\nP by the sizes of these numbers plus separating letters, say,\\\\n(1 + size(ai )) + (1 + size(pi )) + size(n) + size(k) + 1. Note that not all such\\\\ncodes represent instances of (Pk ).\\\\nThe following decision procedure on an alternating Turing machine generalises the\\\\nPSPACE algorithms in [Vardi 1989], given a strictly one-step complete and contraction closed rule set R.\\\\nAlgorithm 6.9. (Decide satisfiability of   F ())\\\\n(1)\\\\n(2)\\\\n(3)\\\\n(4)\\\\n(5)\\\\n\\\\n(Existential) Guess a propositionally consistent pseudovaluation H for .\\\\n(Universal) Choose a contracted clause  =\\\\n6  over MA(H) such that H PL .\\\\n(Universal) Choose an RC -matching [R] of .\\\\n(Existential) Guess a clause  from the CNF of the premise of R.\\\\nRecursively check that (R, ) is satisfiable.\\\\n\\\\nThe algorithm succeeds if all possible choices at steps marked universal lead to\\\\nsuccessful termination, and for all steps marked existential, there exists a choice\\\\nleading to successful termination. Concerning Step 1, note that the only way for a\\\\npseudovaluation to be propositionally inconsistent is to contain both L and L\\\\nfor some modal atom L.\\\\nWe emphasise that in Step 3, it suffices to guess one code for each matching.\\\\nProposition 6.10. Algorithm 6.9 succeeds iff the input formula  is satisfiable.\\\\nProof. Induction over the depth n of . If n = 0, then the propositional formula  will evaluate to either  or , as it does not contain any propositional\\\\nvariables; moreover, the only candidate for a pseudovaluation for  is the empty\\\\nconjunctive clause . Thus, the algorithm terminates unsuccessfully in the existential step (1) iff  evaluates to , since  is a pseudovaluation for  iff  evaluates\\\\n\\\\n\\\\f24\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nto . Otherwise, the algorithm terminates successfully in the universal step (2),\\\\nsince the only clause  over MA() =  such that  PL  is . For n > 0, correctness of the algorithm follows from Corollary 6.4 and the inductive hypothesis:\\\\nthe essential demands of  are the negated premises (/, ) for RC -matchings\\\\n[/] of contracted clauses  as in the algorithm, and such a demand is satisfiable\\\\niff the negation of one of the clauses in the CNF of (/, ) is satisfiable.\\\\nRemark 6.11. In Step 1 of Algorithm 6.9, it suffices to consider the conjunctive\\\\nclauses in some DNF of  rather than all pseudovaluations. A canonical, if not\\\\nnecessarily the most effective choice for such a DNF is to take all pseudovaluations H\\\\nfor  such that MA(H) = MA() (rather than only MA(H)  MA()); in a concrete\\\\nimplementation, a heuristic procedure for determining some DNF effectively may\\\\nbe preferable.\\\\nNote that due to the non-deterministic nature of the algorithm, the above proposition does not imply decidability of F (). This follows only if the algorithm\\\\nrespects suitable resource bounds. We are interested in cases where the algorithm\\\\nruns in polynomial time. The crucial requirement for this is that Steps 3 and 4\\\\ncan be performed in polynomial time, i.e. by suitable nondeterministic polynomialtime multivalued functions (NPMV) [Book et al. 1984]. We recall that a function\\\\nf :   P( ), where  and  are alphabets, is NPMV iff\\\\n(NPMV1) there exists a polynomial p such that |y|  p(|x|) for all y  f (x),\\\\nwhere |  | denotes size, and\\\\n(NPMV2) the graph {(x, y) | y  f (x)} of f is in NP.\\\\nThis motivates the following conditions:\\\\nDefinition 6.12. A set R of rules is called PSPACE -tractable if there exists a\\\\npolynomial p such that all R-matchings of a contracted clause  over F () have\\\\nsome code of size at most p(||) (recall that matchings are equivalence classes of\\\\nrules and thus may have several codes), and it can be decided in NP\\\\n(1) whether a given code is the code of some rule in R;\\\\n(2) whether a rule matches a given contracted clause; and\\\\n(3) whether a clause belongs to the CNF of the premise of a given rule.\\\\nTheorem 6.13 Space Complexity. Let R be strictly one-step complete,\\\\nclosed under contraction, and PSPACE -tractable. Then the satisfiability problem\\\\nfor F () is in PSPACE .\\\\nProof. Since R is PSPACE -tractable, so is RC , assuming reasonable codes for\\\\nthe congruence rules (e.g. consisting of the representation of the relevant modal\\\\noperator; cf. Assumption 6.7). Thus, the functions mapping a clause  to the set of\\\\nits RC -matchings and a rule to the set of clauses occurring in the CNF of its premise,\\\\nrespectively, are NPMV: in the former case, the polynomial bound required by\\\\ncondition (NPMV1) is ensured by the definition of PSPACE -tractability, as we only\\\\nneed to produce one code for each matching, and in the latter case, the polynomial\\\\nbound holds universally, as clauses are of polynomial size. Condition (NPMV2)\\\\nis ensured explicitly by Definition 6.12 and Assumption 6.7 (which implies that\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n25\\\\n\\\\nthe set of formulas is in NP). Therefore, Steps 3 and 4 in Algorithm 6.9 can be\\\\nperformed in polynomial time. Steps 1 and 2 have polynomial runtime without\\\\nspecific assumptions, as a pseudovaluation H for  is represented as a set of literals\\\\nand must by definition satisfy MA(H)  MA(), and the contracted clause  chosen\\\\nin Step 2 is constructed as a non-repetitive list of literals whose negations belong\\\\nto H. Since the depth of recursion is bounded by the depth of , it follows that\\\\nthe algorithm runs in APTIME = PSPACE [Chandra et al. 1981].\\\\nRemark 6.14. A more careful analysis of Algorithm 6.9 reveals that it suffices for\\\\nthe decision problems in Definition 6.12 to be in PH , the polynomial time hierarchy.\\\\nIn our examples, however, the complexity is in fact P rather than NP. We expect\\\\nthat this situation is typical, with the crucial condition for PSPACE -tractability\\\\nbeing the polynomial bound on R-matchings. We are not aware of any natural\\\\nexamples of intractable rule sets (contrived examples are easy to construct, e.g. by\\\\nimposing computationally hard side conditions).\\\\nRemark 6.15. Algorithm 6.9 can be dualised to yield a proof-search procedure\\\\nthat determines whether   L() is R-derivable, thus implementing the shallow\\\\nproof property (Corollary 5.1/Theorem 5.2). Note that the dualisation entails that\\\\nthe roles of existential and universal steps are interchanged.\\\\nIn the treatment of graded and propositional modal logic, the polynomial bound\\\\non rule codes follows rather directly from size estimates in integer linear programming, as follows. Following\\\\nusual practice, we take the size |W | of a raPn\\\\ntional inequality\\\\nW\\\\n\\\\n(\\\\nu\\\\nx\\\\nop u0 ), op  {<, , >, } and ui  Q, to be\\\\ni\\\\ni\\\\ni=1\\\\nPn\\\\n1 + n + i=0 size(ui ). We recall that for n  Z, sgn(n) = 1 if n < 0, sgn(n) = 1\\\\nif n > 0, and sgn(n) = 0 if n = 0.\\\\n\\\\nLemma 6.16. For every rational linear inequality W and every solution\\\\nr0 , . . . , rn  Z of W , there exists a solution sP\\\\n0 , . . . , sn  Z of W such\\\\nPn that sgn(si ) =\\\\nn\\\\nsgn(ri ) for all i, the propositional formulas i=1 si ai  s0 and i=1 ri ai  r0 (cf.\\\\nSection 3) are equivalent, and size(si )  18|W |4 for all i.\\\\n\\\\nProof. Let V = {a1 , . . . , an }, P\\\\nand let x0 , . . . , xn be the variablesP\\\\nin W . We\\\\nn\\\\nn\\\\nequivalent to   i=1 ri ai \\\\nnote that a propositional formula i=1 si ai  s0 isP\\\\nn\\\\na0 P\\\\niff for all valuations  : V  {0, 1}, one has i=1 si (ai )  s0 if and only\\\\nn\\\\nif\\\\ni=1 ri (ai )  r0 , read as integer linear inequalities. Thus, let I denote the\\\\nsystem of inequalities consisting of W and additional inqualities Fi and E , where\\\\ni = 1, . . . , n,  ranges over valuations V  {0, 1},\\\\n\\\\n\\\\nif ri  1\\\\nxi  1\\\\nFi = xi = 0\\\\nif ri = 0\\\\n\\\\n\\\\nxi  1 if ri  1\\\\n(where the middle case actually corresponds to two inequalities), and\\\\n(P\\\\nPn\\\\nn\\\\nxi (ai )  x0 if\\\\nri (ai )  r0\\\\nE = Pi=1\\\\nPi=1\\\\nn\\\\nn\\\\nx\\\\n(a\\\\n)\\\\n<\\\\nx\\\\nif\\\\ni\\\\n0\\\\ni=1 i\\\\ni=1 ri (ai ) < r0 .\\\\n\\\\nThen the claim translates into the statement that I has a solution of polynomially\\\\nbounded size in |W |.\\\\n\\\\n\\\\f26\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nIt follows from [Schrijver 1986, Corollary 17.1b] that I has a solution whose size\\\\nis bounded by 6c(n + 1)3 , where c is the facet complexity of the system, i.e. the size\\\\nof the largest inequality in I. As the cofficients of the inequalities E and Fi are\\\\nof size at most 1, we have c  |W | + 2(n + 1). Since moreover |W |  n + 1, I thus\\\\nhas a solution of size at most 18|W |4 .\\\\nWe now illustrate how Theorem 6.13 allows us to establish PSPACE bounds for\\\\nmany modal logics in a uniform way.\\\\nExample 6.17. Conditions (1) and (2) of Definition 6.12 are immediate for all\\\\nthe rule sets of Example 3.18  the decision problems in question involve no more\\\\nthan checking computationally harmless side conditions in the case of Condition (1)\\\\n(disjointness and containment of finite sets, linear inequalities), and comparing\\\\nclauses of polynomial (in fact, linear) size in the case of Condition (2). Moreover,\\\\nCondition (3) is immediate in those cases where the premises of rules\\\\nP are just single\\\\nclauses. This leaves only GML and PML; but the expansion of iI ri ai  k to\\\\na propositional formula is already in CNF, and checking whether a given clause\\\\nbelongs to this CNF is clearly in P .\\\\nIt remains to establish the polynomial bound on the matchings. For GML and\\\\nPML, this is guaranteed precisely by Lemma 6.16. In all other cases, every contracted clause  matches at most one rule, whose code has size linear in the size\\\\nof .\\\\nWe thus have obtained PSPACE -tractability and hence decidability in PSPACE\\\\nfor all logics in Example 3.18. The logics E and M are of lesser interest here, being\\\\nactually in NP [Vardi 1989]. We briefly comment on the algorithms and bounds\\\\nfor the other cases.\\\\n(1) For the modal logics K and KD (Examples 3.18.3 and 4), Algorithm 6.9 is\\\\nessentially the witness algorithm [Ladner 1977; Vardi 1989; Blackburn et al. 2001].\\\\nBoth logics are PSPACE -hard [Ladner 1977].\\\\n(2) For coalition logic (Example 3.18.5), we arrive, due to minor differences of\\\\nthe rule sets, at a slight variant of Paulys PSPACE -algorithm [Pauly 2002].\\\\n(3) For graded modal logic, we obtain a new algorithm which confirms the known\\\\nPSPACE upper bound [Tobies 2001]. One might claim that the new algorithm is\\\\nnot only nicely embedded into a unified framework, but also conceptually simpler\\\\nthan the constraint-based algorithm of [Tobies 2001] (which corrects a similar but\\\\nincorrect algorithm previously given elsewhere, and refutes a previous EXPTIME\\\\nhardness conjecture). Graded modal logic is PSPACE -hard, as it extends K.\\\\n(4) For probabilistic modal logic, we obtain a new algorithm which confirms\\\\nthe PSPACE upper bound that follows from the corresponding bound for the\\\\nmore expressive (modal) logic of probability, a proof of which is sketched in [Fagin\\\\nand Halpern 1994]. The bound is tight, as PML contains the PSPACE -complete\\\\nlogic KD as a fragment (embedded by mapping  to L1 ). In comparison to the\\\\nalgorithm in loc. cit., our algorithm has additional proof theoretic content as discussed in Section 5. Under the correspondence outlined in Remark 6.15, it finds\\\\nproofs which remain within PML rather than possibly diverting via a more expressive logic.\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n27\\\\n\\\\n(5) Our PSPACE upper bound for majority logic, which appeared for the first\\\\ntime in the conference presentation of [Schr oder and Pattinson 2006], tied in a priority race with [Demri and Lugiez 2006], where a PSPACE upper bound was proved\\\\nfor the more expressive Presburger modal logic using a different type of algorithm.\\\\nThe same remarks concerning proof-theoretic content apply as for probabilistic\\\\nmodal logic.\\\\n7. CONCLUSION\\\\nGeneralising results by Vardi [1989], we have shown that coalgebraic modal logic has\\\\nthe shallow model property, and we have presented a generic PSPACE algorithm\\\\nfor satisfiability based on depth-first exploration of shallow models. We have thus\\\\nreproduced the witness algorithm for K and KD [Blackburn et al. 2001]\\\\nobtained a slight variant of the known PSPACE algorithm for coalition\\\\nlogic [Pauly 2002]\\\\nobtained a new PSPACE algorithm for graded modal logic, recovering the known\\\\nPSPACE bound [Tobies 2001]\\\\nobtained a new PSPACE algorithm for probabilistic modal logic [Larsen and\\\\nSkou 1991; Heifetz and Mongin 2001], recovering a PSPACE upper bound which\\\\nfollows from results sketched in [Fagin and Halpern 1994].\\\\nobtained, simultaneously with [Demri and Lugiez 2006], a new PSPACE upper\\\\nbound for majority logic [Pacuit and Salame 2004].\\\\nIn all these cases, the PSPACE upper bound is tight. Our algorithm may alternatively be viewed as traversing a shallow proof that witnesses a weak subformula\\\\nproperty.\\\\nThe crucial prerequisite for the generic algorithm is an axiomatisation by so-called\\\\none-step rules (going from rank 0 to rank 1) obeying two closedness conditions:\\\\nclosedness under resolution and under contraction, i.e. removal of duplicate literals.\\\\nIn the examples, it has not only turned out that it is feasible to keep this closure\\\\nprocess under control, but also that the axiomatisations obtained have pleasingly\\\\ncompact presentations  typically, one ends up with a single rule schema.\\\\nIt has been shown that every modal logic can be equipped with a canonical\\\\ncoalgebraic semantics, provided it is axiomatisable in rank 1 and satisfies the congruence rule [Schr oder and Pattinson 2007b]. This means in particular that our\\\\nshallow model construction applies to every such modal logic when equipped with\\\\nthe canonical semantics. Moreover, the PSPACE -algorithm presented here can be\\\\nmade modular w.r.t. heterogeneous combination of systems and modal logics using\\\\nmulti-sorted coalgebra [Schr oder and Pattinson 2007a]. The extension of the theory\\\\nbeyond rank 1 is the subject of future research, as is the treatment of simple fixed\\\\npoint operators, possibly using automata theoretic methods [Vardi 1996; Venema\\\\n2006] or pseudomodels [Emerson and Halpern 1985]. A further point of interest is\\\\nto investigate the connection between our notion of resolution closure and classical\\\\nproof-theoretic issues such as cut elimination and interpolation.\\\\n\\\\n\\\\f28\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nACKNOWLEDGMENTS\\\\n\\\\nThe authors wish to thank Alexander Kurz for useful discussions and the Department of Computer Science at the University of Bremen for funding a visit of the\\\\nsecond author.\\\\nREFERENCES\\\\nBarr, M. 1993. Terminal coalgebras in well-founded set theory. Theor. Comput. Sci. 114, 299\\\\n315.\\\\nBartels, F. 2003. Generalised coinduction. Math. Struct. Comput. Sci. 13, 321348.\\\\nBartels, F., Sokolova, A., and de Vink, E. P. 2004. A hierarchy of probabilistic system types.\\\\nTheor. Comput. Sci. 327, 322.\\\\nBlackburn, P., de Rijke, M., and Venema, Y. 2001. Modal Logic. Cambridge University Press,\\\\nCambridge.\\\\nBook, R., Long, T., and Selman, A. 1984. Quantitative relativizations of complexity classes.\\\\nSIAM J. Comput. 13, 461487.\\\\nCarlyle, J. W. and Paz, A. 1971. Realizations by stochastic finite automata. J. Comput. Syst.\\\\nSci. 5, 2640.\\\\nCaro, F. D. 1988. Graded modalities II (canonical models). Studia logica 47, 110.\\\\nChandra, A., Kozen, D., and Stockmeyer, L. 1981. Alternation. J. ACM 28, 114133.\\\\nChellas, B. 1980. Modal Logic. Cambridge University Press, Cambridge.\\\\nCrstea, C. and Pattinson, D. 2007. Modular construction of complete coalgebraic logics.\\\\nTheor. Comput. Sci.. In press.\\\\nDAgostino, G. and Visser, A. 2002. Finality regained: A coalgebraic study of Scott-sets and\\\\nmultisets. Arch. Math. Logic 41, 267298.\\\\nDe Nivelle, H., Schmidt, R. A., and Hustadt, U. 2000. Resolution-based methods for modal\\\\nlogics. Logic J. IGPL 8, 265292.\\\\nDemri, S. and Lugiez, D. 2006. Presburger modal logic is only PSPACE-complete. In IJCAR 2006, Proceedings of the Third International Joint Conference on Automated Reasoning,\\\\nU. Furbach and N. Shankar, Eds. Lect. Notes Artificial Intell., vol. 4130. Springer, Berlin,\\\\n541556. Full version available as Research Report LSV-06-15, Laboratoire Sp \\\\necification et\\\\nV \\\\nerification, Ecole Normale Sup \\\\nerieure de Cachan, 2006.\\\\nEmerson, E. A. and Halpern, J. Y. 1985. Decision procedures and expressiveness in the temporal logic of branching time. J. Comput. Syst. Sci. 30, 124.\\\\nFagin, R. and Halpern, J. Y. 1994. Reasoning about knowledge and probability. J. ACM 41,\\\\n340367.\\\\nFine, K. 1972. In so many possible worlds. Notre Dame J. Formal Logic 13, 516520.\\\\nHalpern, J. and R\\\\nego, L. C. 2007. Characterizing the NP-PSPACE gap in the satisfiability\\\\nproblem for modal logic. In IJCAI 2007, Proceedings of the 20th International Joint Conference\\\\non Artificial Intelligence, M. M. Veloso, Ed. 23062311.\\\\nHansen, H. H. and Kupke, C. 2004. A coalgebraic perspective on monotone modal logic. In\\\\nCoalgebraic ",
    "Methodology": "Methods in Computer Science, J. Ad \\\\namek and S. Milius, Eds. Electron. Notes\\\\nTheor. Comput. Sci., vol. 106. Elsevier, Amsterdam, 121143.\\\\nHeifetz, A. and Mongin, P. 2001. Probabilistic logic for type spaces. Games and Economic\\\\nBehavior 35, 3153.\\\\nJacobs, B. 2000. Towards a duality result in coalgebraic modal logic. In CMCS 2000, Coalgebraic\\\\nMethods in Computer Science, H. Reichel, Ed. Electron. Notes Theor. Comput. Sci., vol. 33.\\\\nElsevier, Amsterdam.\\\\nKupke, C., Kurz, A., and Pattinson, D. 2005. Ultrafilter extensions for coalgebras. In CALCO\\\\n2005, Algebra and Coalgebra in Computer Science: First International Conference, Proceedings, J. L. Fiadeiro, N. Harman, M. Roggenbach, and J. Rutten, Eds. Lect. Notes Comput.\\\\nSci., vol. 3629. Springer, Berlin, 263277.\\\\nKurz, A. 2001. Specifying coalgebras with modal logic. Theor. Comput. Sci. 260, 119138.\\\\n\\\\n\\\\fPSPACE Bounds for Rank-1 Modal Logics\\\\n\\\\n\\\\n\\\\n29\\\\n\\\\nLadner, R. 1977. The computational complexity of provability in systems of modal propositional\\\\nlogic. SIAM J. Comput. 6, 467480.\\\\nLarsen, K. and Skou, A. 1991. Bisimulation through probabilistic testing. Inf. Comput. 94,\\\\n128.\\\\n  der, L., Roggenbach, M., and Reichel, H. 2006. AlgebraicMossakowski, T., Schro\\\\ncoalgebraic specification in CoCasl. J. Logic Algebraic Programming 67, 146197.\\\\nOhlbach, H. J. and Koehler, J. 1999. Modal logics, description logics and arithmetic reasoning.\\\\nArtificial Intelligence 109, 131.\\\\nPacuit, E. and Salame, S. 2004. Majority logic. In KR 2004, Principles of Knowledge Representation and Reasoning: Proceedings of the Ninth International Conference, D. Dubois, C. A.\\\\nWelty, and M.-A. Williams, Eds. AAAI Press, 598605.\\\\nPattinson, D. 2001. Semantical principles in the modal logic of coalgebras. In STACS 2001,\\\\n18th Annual Symposium on Theoretical Aspects of Computer Science, Proceedings, A. Ferreira\\\\nand H. Reichel, Eds. Lect. Notes Comput. Sci., vol. 2010. Springer, Berlin, 514526.\\\\nP",
    "Experiment": "attinson, D. 2003. Coalgebraic modal logic: Soundness, completeness and decidability of local\\\\nconsequence. Theor. Comput. Sci. 309, 177193.\\\\nPattinson, D. 2004. Expressive logics for coalgebras via terminal sequence induction. Notre\\\\nDame J. Formal Logic 45, 1933.\\\\nPauly, M. 2002. A modal logic for coalitional power in games. J. Logic and Comput. 12, 149166.\\\\nPauly, M. 2005. On the role of language in social choice theory. Unpublished manuscript.\\\\nRabin, M. 1963. Probabilistic automata. Inform. Control 6, 230245.\\\\n  iger, M. 2000. Coalgebras and modal logic. In CMCS 2000, Coalgebraic Methods in ComRo\\\\nputer Science, H. Reichel, Ed. Electron. Notes Theor. Comput. Sci., vol. 33. Elsevier, Amsterdam.\\\\nRothe, J., Tews, H., and Jacobs, B. 2001. The Coalgebraic Class Specification Language CCSL.\\\\nJ. Universal Comput. Sci. 7, 175193.\\\\nRutten, J. 2000. Universal coalgebra: A theory of systems. Theor. Comput. Sci. 249, 380.\\\\nSchrijver, A. 1986. Theory of linear and integer programming. John Wiley & Sons, Chichester.\\\\n  der, L. 2005. Expressivity of coalgebraic modal logic: the limits and beyond. In FOSSchro\\\\nSACS 2005, Foundations of Software Science and Computation Structures, 8th International\\\\nConference, Proceedings, V. Sassone, Ed. Lect. Notes Comput. Sci., vol. 3441. Springer, Berlin,\\\\n440454. Extended version to appear in Theor. Comput. Sci.\\\\n  der, L. 2007. A finite model construction for coalgebraic modal logic. J. Logic Algebraic\\\\nSchro\\\\nProgramming. In press. Earlier version in Foundations of Software Science And Computation\\\\nStructures, vol. 3921 of Lect. Notes Comput. Sci., pp. 157171, Springer, Berlin, 2006.\\\\n  der, L. and Pattinson, D. 2006. PSPACE reasoning for rank-1 modal logics. In\\\\nSchro\\\\nLICS 2006, Proceedings of the 21st Annual IEEE Symposium on Logic in Computer Science, R. Alur, Ed. IEEE Computer Society Press, 231240. Presentation slides available under\\\\nwww.informatik.uni-bremen.de/lschrode/slides/rank1pspac",
    "Discussion": "e.pdf.\\\\n  der, L. and Pattinson, D. 2007a. Modular algorithms for heterogeneous modal logics. In\\\\nSchro\\\\nICALP 2007, Automata, Languages and Programming, 34th International Colloquium, Proceedings, L. Age, A. Tarlecki, and C. Cachin, Eds. Lect. Notes Comput. Sci. Springer, Berlin.\\\\nTo appear.\\\\n  der, L. and Pattinson, D. 2007b. Rank-1 modal logics are coalgebraic. In STACS 2007,\\\\nSchro\\\\n24th Annual Symposium on Theoretical Aspects of Computer Science, Proceedings, W. Thomas\\\\nand P. Weil, Eds. Lect. Notes Comput. Sci., vol. 4393. Springer, Berlin, 574585.\\\\nTobies, S. 2001. PSPACE reasoning for graded modal logics. J. Logic and Comput. 11, 85106.\\\\nTroelstra, A. S. and Schwichtenberg, H. 1996. Basic Proof Theory. Cambridge Tracts in\\\\nTheoretical Computer Science, vol. 43. Cambridge University Press, Cambridge.\\\\nTuri, D. and Plotkin, G. 1997. Towards a mathematical operational semantics. In LICS\\\\n1997, Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science. IEEE\\\\nComputer Society Press, 280291.\\\\n\\\\n\\\\f30\\\\n\\\\n\\\\n\\\\nL. Schr \\\\noder and D. Pattinson\\\\n\\\\nvan der Hoek, W. and Meyer, J.-J. 1992. Graded modalities in epistemic logic. In LFCS\\\\n1992, Logical Foundations of Computer Science, Second International Symposium, Proceedings,\\\\nA. Nerode and M. A. Taitslin, Eds. Lect. Notes Comput. Sci., vol. 620. Springer, Berlin, 503\\\\n514.\\\\nVardi, M. 1989. On the complexity of epistemic reasoning. In LICS 1989, Proceedings of the\\\\nFourth Annual IEEE Symposium on Logic in Computer Science. IEEE Computer Society Press,\\\\n243251.\\\\nVardi, M. Y. 1996. Why is modal logic so robustly decidable? In Descriptive Complexity and\\\\nFinite Models, Proceedings of a DIMACS Workshop, N. Immerman and P. G. Kolaitis, Eds.\\\\nDIMACS Ser. in Discrete Math. and Theor. Comput. Sci., vol. 31. American Mathematical\\\\nSociety, 149184.\\\\nVenema, Y. 2006. Automata and fixed point logics: a coalgebraic perspective. Inf. Comput. 204,\\\\n637678.\\\\n\\\\n\\\\f\"}\\n'"
  },
  "key_words": {
    "Abstract": [
      [
        "complexity modal logics",
        0.7099
      ],
      [
        "modal logic smallest",
        0.6401
      ],
      [
        "theory complexity modal",
        0.6332
      ],
      [
        "rank modal logics",
        0.626
      ],
      [
        "modal logics graded",
        0.6223
      ]
    ],
    "Introduction": [
      [
        "clauses called resolution",
        0.6923
      ],
      [
        "logics example resolution",
        0.6227
      ],
      [
        "closedness resolution statement",
        0.6192
      ],
      [
        "resolution closure rules",
        0.6164
      ],
      [
        "resolution obtains rules",
        0.6161
      ]
    ],
    "Related Work": [
      [
        "nthe propositional theory",
        0.5422
      ],
      [
        "nthe propositional",
        0.517
      ],
      [
        "theorem 17 schr",
        0.5105
      ],
      [
        "pseudovaluation propositionally entailed",
        0.5011
      ],
      [
        "rule propositionally entails",
        0.4987
      ]
    ],
    "Methodology": [
      [
        "logic coalgebras",
        0.6742
      ],
      [
        "coalgebra computer science",
        0.6533
      ],
      [
        "modal logic coalgebras",
        0.6487
      ],
      [
        "coalgebras modal logic",
        0.6369
      ],
      [
        "coalgebraic modal logic",
        0.6304
      ]
    ],
    "Experiment": [
      [
        "expressive logics coalgebras",
        0.6737
      ],
      [
        "coalgebraic modal logic",
        0.6619
      ],
      [
        "coalgebras modal logic",
        0.6418
      ],
      [
        "logics coalgebras",
        0.6379
      ],
      [
        "logics coalgebras terminal",
        0.5882
      ]
    ],
    "Discussion": [
      [
        "graded modal logics",
        0.6725
      ],
      [
        "heterogeneous modal logics",
        0.6427
      ],
      [
        "reasoning graded modal",
        0.5981
      ],
      [
        "algorithms heterogeneous modal",
        0.597
      ],
      [
        "2007a modular algorithms",
        0.588
      ]
    ]
  },
  "summarization": {
    "Abstract": "all rank-1 logics enjoy a shallow model property and are in PSPACE. This leads to a unified derivation of tight PSPACE -bounds for a number of logics. The work is a step towards a general theory of the complexity of modal logics\u00a0.",
    "Introduction": "Resolution closure is the syntactic counterpart of strict one-step completeness. We show that a set of rules is resolution closed if all clauses in a set are propositional. We extend the idea to first-order logic in a number of ways. We prove that the rules can be defined in terms of a finite set of propositions.",
    "Related Work": "propositional theory of propositional reasoning is the theory of the conjunction of clauses in propositional logic. Theorem 5.6 says that a rule system is complete if it has enough propositional symbols to be a complete set of rules. The rule system can be described by a weak subformula property.",
    "Methodology": "\"Coalgebraic modal logic\" is a form of propositional logic. It is a type of probabilistic logic. The logic can be used to predict the behaviour of objects in a game. It can also be applied to other types of logic and systems of logic.",
    "Experiment": "\"Coalgebraic modal logic\" is a theory of linear and integer programming. The theory is based on the theory of coalgebras and modal logics. This paper is an extended version of an earlier version of the paper published in 2003. The author has proposed a new model for coalgebraic logic.",
    "Discussion": "modular algorithms for heterogeneous modal logics are coalgebraic. modal logic is a form of propositional logic. der, L. and Pattinson: Rank-1 modallogics are decidable but not Turing-complete. The authors argue that theorems in the form of polynomials can be used to explain modal reasoning."
  }
}